---
base-css:
-   https://carnap.io/shared/dsanson@gmail.com/sanson-book.css
-   https://cdn.plyr.io/3.6.12/plyr.css
js: 
-   https://cdn.plyr.io/3.6.12/plyr.polyfilled.js
-   https://carnap.io/shared/dsanson@gmail.com/logic-book.js
---

::: cover

# Predicate Logic (PL)

::: illustration
![Everything
Is](https://dsanson.github.io/logic-materials/img/everything_is.gif){alt='Benny
the spaceman from the Lego Movie screams. Caption says "Everything Is".'}
:::
:::


This chapter introduces [Predicate Logic (PL)]{.vocab}. Predicate Logic is an
*extension* of the [Sentential Logic (SL)]{.vocab} we've studied in earlier
chapters. It allows us to explore the logical relations between *singular
claims* and *generalizations*. For example, the relations between 'Lil Nas X
is awesome', 'Someone is awesome', 'Everyone is awesome', and 'Nobody is
awesome.'

The specific learning objectives for
this chapter are:

a.  I can parse symbolic formulas, identifying the main connective, and
    identifying the scope of each connective.
b.  I can identify which variables in a formula are free and which are
    bound
c.  I can identify instances of generalizations, and generalizations of
    instances

## Some Valid Argument Forms

The following argument is obviously valid:

::: standardform
-   Everything is awesome
-   Benny is awesome
:::

And it is obviously valid in virtue of its *logical form*, which it shares
with other valid arguments, like:

::: standardform
-   Everything is cool
-   Lucy is cool
:::

Note that our reasoning is valid when we reason *from* a claim about everything *to* a claim about some specific thing, but not vice versa. This argument is *not* valid:

:::{.standardform .xed}
-   Lucy is cool
-   Everything is cool
:::

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
1 Can you give your own example of a valid argument of the same form as the two above?
```

Here is another obviously valid argument:

::: standardform
-   Benny is awesome
-   Something is awesome
:::

Again, it is clear that any argument of this form is valid. And, again, it is
clear that reasoning in the other direction, *from* a claim about something
*to* a claim about some specific thing, is not valid:

:::{.standardform .xed}
-   Something is awesome
-   Benny is awesome
:::

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
2 Can you give your own example of a valid argument of the same form as above?
```

In Logic and Philosophy of Language we make a sharp distinction between
*singular terms* and *general terms*:

Singular term
:   [A [singular term]{.vocab} is a noun or noun phrase that by design refers
    just to a single object.]{.def}

Examples of singular terms include proper names, like 'Taylor Swift', 'Normal,
IL', and 'Lil Nas X'. But also, *definite descriptions*: noun phrases that
begin with the word 'the', like 'the tallest player in the NBA'. Also, many
singular pronouns and demonstratives, like 'this', 'that', and 'it', along
with singular personal pronouns, like 'ze', 'he', 'she', and 'they' (in its
singular use).

General term
:   [A [general term]{.vocab} is a noun or noun phrase that by design refers
    to several things, or to a type or group of things.]{.def}

Examples of general terms include common nouns, like 'popstar', 'city', 'frog'. 
There are lots of popstars, but there is only one Taylor Swift.

My examples above all used *singular terms*.
But plausibly, there are valid arguments of the same form that use *general terms* instead, e.g.,

:::standardform
-   Everything is awesome.
-   Mud is awesome.
:::

:::standardform
-   Frogs are cool.
-   Something is cool.
:::

As it turns out, there are good reasons to think that, while these arguments
share a *superficial* form with the others, their *underlying* logical form is
a bit different.

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
3 In your answers to (1) and (2), did you give examples using singular terms or general terms?
```

## The Limits of SL

In SL, the basic units of analysis are the atomic sentences, represented by
sentence letters P, Q, R,.... We glue these atomic sentences together using
sentential connectives, to generate a wide range of molecular logical forms.

At first blush, these methods simply do not allow us to explain the validity
of the arguments described in the previous section, as the premise and
conclusion are two distinct atomic sentences:

::: standardform
-   P: Everything is awesome
-   Q: Benny is awesome
:::

However, recall that at the end of [Chapter 8](08R#quantification), we
introduced some techniques for dealing with phrases like 'some of us' and 'all
of us' in SL. Suppose (sticking with the Lego Movie theme) we are Benny, Lucy,
Emmet, Unikitty, and Batman. And suppose we have an appropriate scheme of
abbreviation. Then we can treat 'All of us are awesome' as:

:::transl
| All of us are awesome.
| Benny is awesome and Lucy is awesome and Emmet is awesome and Unikitty is
    awesome and Batman is awesome.
| P ∧ Q ∧ R ∧ S ∧ T
:::

But what if we want to drop the restriction to *us*? What if we want to say
that *everything* is awesome? We are going to need a longer list.

:::aside
<div style="width:100%;height:0;padding-bottom:42%;position:relative;"><iframe src="https://giphy.com/embed/57x4ApyRzkI1y" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/jaws-roy-scheider-57x4ApyRzkI1y">via GIPHY</a></p>
:::

Specifically, we need a scheme that looks something like this:

:::soa
| P<sub>1</sub>: Benny is awesome
| P<sub>2</sub>: Lucy is awesome
| P<sub>3</sub>: Emmet is awesome
| P<sub>4</sub>: Unikitty is awesome
| P<sub>5</sub>: Batman is awesome
| P<sub>6</sub>: David is awesome
| P<sub>7</sub>: Lil Nas X is awesome
| P<sub>8</sub>: Normal, IL is awesome
| ⋮
:::

And so on, for *every* *single* *thing* there is.

Suppose we had this scheme. Then:

:::transl
| Everything is awesome
| P<sub>1</sub> ∧ P<sub>2</sub> ∧ P<sub>3</sub> ∧ P<sub>4</sub> ∧ P<sub>5</sub> ∧ P<sub>6</sub> ∧ P<sub>7</sub> ∧ P<sub>8</sub>‥.
:::

And likewise,

:::transl
| Something is awesome
| P<sub>1</sub> ∨ P<sub>2</sub> ∨ P<sub>3</sub> ∨ P<sub>4</sub> ∨ P<sub>5</sub> ∨ P<sub>6</sub> ∨ P<sub>7</sub> ∨ P<sub>8</sub>‥.
:::

Armed with this scheme, we can represent the argument that Benny is awesome since everything is awesome as:

:::standardform
-   P<sub>1</sub>∧P<sub>2</sub>∧P<sub>2</sub>∧P<sub>3</sub>∧P<sub>4</sub>∧...
-   P<sub>1</sub>
:::

Can we complete this derivation in our system? That depends on how many things
there are. If there are finitely many things, then that first premise is
finitely long. So, in principle, yes. But in practice, no. At minimum, that
first premise will need as many conjuncts as there are particles in the
universe. But that means that it will be too long to write down on paper, and
too long to explicitly represent in any medium. And recall that conjunctions
group to the left. So, to complete the derivation, and derive the leftmost
conjunct, we will need to apply the rule S not just once, but once for every
conjunction in the premise.

If there are infinitely many things, then the first premise is infinitely
long. But there are no infinitely long conjunctions in SL. For any finite
number *n*, we can build a sentence with *n* ∧'s. But we cannot build a
sentence with infinitely many ∧'s. (If you aren't sure about this, ask
yourself this: would an infinite conjunction have a main connective?)

Nor is this problem about infinity is not an academic theoretical problem that we don't have to worry about in practice. Consider:

:::standardform
-   Every natural number is odd or even.
-   5 is odd or even.
:::

This argument is obviously valid, and it is a relatively trivial bit of
mathematical reasoning. But there are infinitely many natural numbers. We need
a logic that doesn't blow up in the face of examples like this.


## Splitting the Atom(ic Sentences)

Suppose your stoner bro friend, while high, says,

:::displayed
-   Everything is so freaking cosmic!
:::

You ask him what he means, and he replies: 

> I mean absolutely everything, bestie: This joint is cosmic! Your shirt is
> cosmic! And the planets: Earth is cosmic! So is Mars! And Pluto, even if it
> isn't a planet. And this cheeto is cosmic. And that one! And that little bit
> of cheese powder! And think about numbers! Like the number 537! It is so
> freaking cosmic!...

:::illustration
![Cosmic Cheeto Cat](https://dsanson.github.io/logic-materials/img/cosmic_cheeto_cat.gif)
:::

And he just keeps going.

His list is long. But also, it is repetitive. Each time, he applies the *same
predicate* to a thing. The predicate is:

::: {.displayed}
-   []{.blank} is cosmic.
:::

Each of his claims can be thought of as the result of plugging a singular term
into that box, generating a new simple sentence:

::: {.displayed}
-   [Your shirt]{.blank} is cosmic.
-   [The number 537]{.blank} is cosmic.
-   [This cheeto]{.blank} is cosmic.
-   ⋮
:::

Suppose that instead of a singular term, we plug in a [variable]{.vocab}:

::: {.displayed}
-   [*x*]{.blank} is cosmic.
:::

This doesn't quite give us another *sentence*. Instead, it gives us a
*formula*. We can ask: for what values of *x* is this formula true? And for
what values of *x* is it false?

And we know what your friend would say:

::: {.displayed}
-   The formula '[*x*]{.blank} is cosmic' is true for every value of *x*.
:::

Much to your friend's satisfaction, putting his point this way even allows us
to include things that don't have names. ("Whoa! Think of all the nameless
things in the universe: each one is so freaking cosmic!")

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
4 Suppose you disagree with your stoner bro friend, and think that some things are not cosmic. Can you express that as a claim about the formula 'x is cosmic'?
```

## Predicates and Constants

We start with a simplified view about the structure of simple sentences, and
imagine that each simple sentence is composed of two parts: a subject and a
predicate. Further, we imagine that the subject is always a *singular term*,
like 'Taylor Swift' or 'the Pacific Ocean', and the predicate is always a verb
or a verb phrase, like 'is deep' or 'is sleepy'.

For example,

::: displayed
-   [Thundercat]{.blank} is sleepy.
-   [Thundercat]{.blank} plays bass.
:::

In the first example, 'Thundercat' is the subject, and '[]{.blank} is sleepy'
is the predicate. The second example has the same subject, 'Thundercat', but a
different predicate.

Following this idea, we extend our artificial language to include singular
terms, predicates, and sentences built from singular terms and predicates. We
call this extended language the language of Predicate Logic, or PL for short.
PL is an *extension* of SL in the sense that it contains everything from SL
*and more*. So we keep all our sentence letters and we keep all our
connectives. We add [constants]{.vocab}, meant to play the role of singular
terms. These are lowercase letters 'a' through 'e'. And we add [predicate
letters]{.vocab}. These are uppercase letter 'F' through 'O'.

:::vaside
-   [[Predicate letters]{.vocab}: uppercase letters '*F*' through '*O*',
    optionally with numerical subscripts.]{.def}
-   [[Constants]{.vocab}: lowercase letters, '*a*' through '*e*',
    optionally with numerical subscripts.]{.def}
:::

Here is a scheme of abbreviation for PL:

:::soa
| F: []{.blank} is sleepy
| G: []{.blank} plays bass
| R: It is raining
| a: Thundercat
| b: Taylor Swift
:::

Using this scheme, we can render simple sentences of English into PL:

::: transl
| Thundercat is sleepy.
| F(a)
:::

Notice the syntax. In English, we usually begin a sentence with its subject,
followed by its predicate. In PL, we begin a sentence with its predicate, followed by the
subject. And we put the subject in parentheses. This syntax is meant to
suggest the familiar '*f(x)*' notation from mathematics, for applying a *function* to an
*argument*. 


:::wrapper
:::soasticky
| F: []{.blank} is sleepy
| G: []{.blank} plays bass
| a: Thundercat
| b: Taylor Swift
:::

```{.Translate .FOL points=10}
5 G(a): Thundercat plays bass.
```

:::{.reaction .correct ex=3}
You can think of a predicate as a function from an object to a truth value. For example, the predicate 'G' takes Thundercat to true, since it is true that Thundercat plays bass. But 'G' takes Taylor Swift to false, since she does not play bass.
:::

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.5.mp4)
:::

```{.Translate .FOL points=10}
6 F(b): Taylor Swift is sleepy.
```

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.6.mp4)
:::

Simple sentences constructed from a predicate and a constant, like 'F(a)', are
atomic. They work just like 'P's and 'Q's. We can glue them together, using
our connectives, to generate molecular sentences:

::: transl
| Thundercat is not sleepy.
| ¬F(a)
:::

Also,

:::transl
| Thundercat plays bass and Taylor Swift play bass
| G(a) ∧ G(b)
:::

Students first encountering PL often forget how to use connectives to generate
molecular sentences. Asked to translate 'Thundercat and Taylor Swift play bass', they offer solutions like:

:::{.transl .xed}
| G(ab)
:::

Or maybe,

:::{.transl .xed}
| G(a)G(b)
:::

But these aren't sentences in PL. 

If you are tempted to write something like 'F(¬a)', don't. You cannot apply
negation, '¬', to a constant. You cannot *negate things*. You can only negate
sentences. So, to express 'Thundercat is not sleepy', first construct
'Thundercat *is* sleepy', and then negate that:

:::{.transl}
| Thundercat is not sleepy
| It is not the case that Thundercat is sleepy
| It is not the case that F(a)
| ¬F(a)
:::

If you are tempted to write something like 'G(a)G(b)', 'G(ab), or 'G(a∧b)', don't. The
first, 'G(a)G(b)', is two atomic sentences smooshed together without a
connective. It is no more a sentence in PL than 'PQR' is a sentence in SL. The
second, 'G(ab)', attemps to smoosh two constants together without a connective. Again, that is not something we can do. The last,
'G(a∧b)', attempts to conjoin the constants, 'a' and 'b', using our connective, '∧'. But
'∧' is a *sentential* connective: it conjoins *sentences*, not *things*: 

:::{.transl}
| Thundercat and Taylor Swift play bass.
| Thundercat plays bass and Taylor Swift plays bass.
| G(a) and G(b)
| G(a) ∧ G(b)
:::

:::

:::wrapper
:::soasticky
| F: is sleepy
| G: stayed up all night dancing
| a: Liam
| b: Harry
| c: Zayn
:::

```{.Translate .FOL points=10}
7 G(a)/\G(b)/\G(c): Liam, Harry, and Zayn stayed up all night dancing
```

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.7.mp4)
:::

```{.Translate .FOL points=10}
8 F(a)/\~F(b) : Liam is sleepy but Harry is not
```

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.8.mp4)
:::

```{.Translate .FOL points=10}
9 G(a)->F(a): If Liam stayed up all night dancing, then Liam is sleepy
```

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.9.mp4)
:::

```{.Translate .FOL points=10}
10 ~G(c)->~F(c): Zayn is not sleepy if he didn't stay up all night dancing 
```

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.10.mp4)
:::

:::

## Variables and Formulas

In the previous section, we introduced predicates and constants. Next, we
introduce variables. A [constant]{.vocab} is a singular term that always
refers to the same thing. A [variable]{.vocab} is a singular term that can be
assigned different values. For variables, we use lowercase letters '*v*'
through '*z*', optionally with numeric subscripts.

Syntactically, variables work a lot like constants:

:::transl
| Zayn is sleepy
| F(c)
| *x* is sleepy
| F(x)
| *y* is sleepy
| F(y)
:::

We call 'F(x)' and 'F(y)' [formulas]{.vocab}, but not sentences.
Remember, a [sentence]{.vocab} in our technical sense is the sort of thing
that can be true or false. 'Zayn is sleepy' is a sentence in this sense, and
it is either true or false. But '*x* is sleepy' isn't a sentence in this
sense. It has a *gap*, an *unspecified value*. And until we *fill* that gap,
or *specify* that value, it is not yet a complete claim, that can be evaluated
as true or false.
That is, it only makes sense to ask whether or
not '*x* is sleepy' is true or false *relative to an assignment* of some value
to the variable *x*.

```{.QualitativeProblem .MultipleSelection points=10}
11 Which of the following are sentences in our technical sense?
| *Normal is in Illinois
| *San Francisco is in Illinois
| x is in Illinois
| y is less than 4
| *3 is less than 4
| *5 is less than 4
```

'F(x)' and 'F(y)' and are *atomic* formulas. Just as we can combine atomic sentences, using our connectives, to build molecular sentences, we can combine atomic formulas, using our connectives, to build molecular formulas.

:::wrapper
:::soasticky
| F: is a frog
| G: is green
:::


```{.Translate .FOL points=10}
12 F(x)/\G(x): x is a frog and x is green
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.16.mp4)
:::

```{.Translate .FOL points=10}
13 F(x)/\G(y): x is a frog and y is green
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.17.mp4)
:::

```{.Translate .FOL points=10}
14 ~F(x)/\~F(y): x is not a frog and y is not a frog 
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.18.mp4)
:::

```{.Translate .FOL points=10}
15 F(x)->G(x): If x is a frog then x is green
```

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.19.mp4)
:::

:::

## Quantifiers

Finally, we introduce two [quantifiers]{.vocab}:

The [universal quantifier]{.vocab}
:   '∀': this can be read as 'for all' or 'for every' or 'for each'.

The [existential quantifier]{.vocab}
:   '∃': this can be read as 'for some' or 'there exists' or 'there is a' or 'for at least one'.

The universal quantifier looks like an upside down 'A'. You can think of the
'A' as standing for 'all'. The existential quantifier looks like a backwards 'E'. 
You can think of the 'E' as standing for 'exists'.

Quantifiers quantify over variables.
So, to use a quantifier, first combine it with a variable to form a [quantifier phrase]{.vocab},
 then prefix that quantifier phrase to a formula.
A quantifier phrase is just a quantifier followed by a variable.
So '∀x', '∀y', '∃z', and so on.

That is all pretty abstract. Here is an example:

:::transl
| ∀xF(x)
| Every x is such that x is F.
:::

The quantifier phrase, '∀x', is read as 'Every x is such that'. It is attached
as a prefix to the formula, 'F(x)'. This allows us to say that *everything* is
F.

The quantifier phrase '∃y' can be read as 'Some y is such that' or 'There exists a y such that':

:::displayed
| ∃yF(y)
| Some y is such that y is F.
| There exists a y such that y is F.
:::

This allows us to say that *something* is F.


:::wrapper
:::soasticky
| G: is good
| b: Bridger
:::

Or, again:

:::transl
| ∀xG(x)
| Every x is such that x is good.
:::

And,

:::transl
| ∃x¬G(x)
| Some x is such that x is not good.
:::

These aren't quite English sentences, because English doesn't have variables.
The closest thing to a variable in English is a *pronoun*:

::: transl
| ∀xG(x)
| Everything is such that *it* is good.
:::

::: transl
| ∃x¬G(x)
| Something is such that *it* is not good.
:::

This gets us English, but not idiomatic English. Idiomatic English simpler constructions, that omit the pronouns:

::: transl
| ∀xG(x)
| Everything is good.
:::

And,

:::transl
| ∃xG(x)
| Something is good.
:::

In this way, idiomatic English *hides* and *obscures* important differences in logical form. 
The sentence 'Everything is good' *looks like* it has the same grammatical form as the sentence 'Bridger is good'.
But 'Bridger' is a constant, while 'Everything' is a quantificational phrase.
PL displays and clarifies this difference in logical form, rendering the first as a simple atomic sentence, 'G(b)', and the second as a complex sentence built from the formula, 'x is good', and the quantifier phrase: '∀xG(x)'.

:::

:::wrapper
:::soasticky
| F: is funny
| G: is goofy
:::

(Your keyboard likely doesn't have keys for '∃' or '∀'. Use "E" for '∃', and "A" for '∀'.)

```{.Translate .FOL points=10} 
16 AxF(x) : Every thing is such that it is funny.
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.20.mp4)
:::

```{.Translate .FOL points=10} 
17 ExG(x) : Some thing is such that it is goofy.
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.21.mp4)
:::

```{.Translate .FOL points=10} 
18 ~AxF(x) : Not every thing is such that it is funny.
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.22.mp4)
:::

```{.Translate .FOL points=10} 
19 AxG(x) : All things are goofy.
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.23.mp4)
:::

```{.Translate .FOL points=10} 
20 Ex~F(x) : Some things are not funny.
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.24.mp4)
:::

```{.Translate .FOL points=10} 
21 ExF(x)/\Ex~F(x): Some things are funny and some things aren't.
```
:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.25.mp4)
:::

:::

## Official Syntax 

The previous sections introduced the language PL informally. In this section,
we consider the official formal rules for its syntax.

First, we list the symbols of PL:

1. [Sentence letters]{.vocab}, '$P,Q,\ldots,W'$ 
2. [Terms]{.vocab}, which come in two types:
    -  [constants]{.vocab}: "$a,b,c,d,e$"
    -  [variables]{.vocab}: "$v,w,x,y,z$"
3. [Predicate letters]{.vocab}: $F,G,\ldots,O,$
4. [Sentential connectives]{.vocab}: '¬, ∧, ∨, →, ↔'
5. [Quantifiers]{.vocab}: '∀' and '∃'
6. Left and right parentheses.

Officially, sentence letters, terms, and predicates can all have numerical
subscripts, so we don't have to worry about running out.

Next, a couple of definitions. In PL, [atomic formulas]{.vocab} come in two varieties:

-   Each sentence letter is an atomic formula.
-   Any predicate letter followed by any term in parentheses (e.g., 'F(a)') is an atomic
    formula.

And a [quantifier phrase]{.vocab} is a quantifier ('∀', '∃') followed by a variable (e.g., '∀x' and '∃z').

Finally, we offer our recursive definition of a [formula]{.vocab} in PL:

:::liveshapes
1.  Every atomic formula is a formula.
2.  If []{.P} and []{.Q} are both formulas, then:
    a.  ¬[]{.P} is a formula,
    b.  ([]{.P} ∧ []{.Q}) is a formula,
    c.  ([]{.P} ∨ []{.Q}) is a formula,
    d.  ([]{.P} → []{.Q}) is a formula,
    e.  ([]{.P} ↔ []{.Q}) is a formula,
3.  If []{.S} is a quantifier phrase, and []{.P} is a formula, []{.S}[]{.P} is a formula. 
:::

Just as we did in Unit 3, we can explore the syntax of a given formula by parsing it into a tree.
Here is the tree for '∀x(F(x)∧G(x))':

:::illustration
![Tree for ∀x(F(x)∧G(x))](https://dsanson.github.io/logic-materials/img/AxKFxGx.png)
:::

At the top node, we have our formula, '∀x(F(x)∧G(x))'. This was constructed, by rule (3), by attaching the quantifier phrase, '∀x', to the formula '(F(x)∧G(x))'. And that formula was constructed, by rule (2b), from 'F(x)' and 'G(x)', which are both atomic formulas.

Here is the tree for '(∀xF(x)∧∀xG(x))':

:::illustration
![Tree for (∀xF(x)∧∀xG(x))](https://dsanson.github.io/logic-materials/img/KAxFxAxGx.png)
:::

At the top node, we have our formula, '(∀xF(x)∧∀xG(x))'. This was constructed, by rule (2b), from '∀xF(x)' and '∀xG(x)'.
'∀xF(x)' is constructed, by rule (3), by attaching the quantifier phrase '∀x' to the atomic formula 'F(x)'. And, similarly, '∀xG(x)' is constructed by rule (3), attaching '∀x' to 'G(x)'.

As always, the [main connective]{.vocab} of a formula is the last connective
added. But now sometimes the main connective is a quantifier phrase instead of
a sentential connective. So, for example, the main connective of '∀x(F(x) ∨
G(x))' is the quantifier phrase, '∀x', while the main connective of '(∀xF(x) ∨
∀xG(x))' is the disjunction, '∨'.

When the main connective of a formula is a quantifier phrase, we call that
formula a [generalization]{.vocab}. When it is an existential quantifier
phrase, we call it an [existential generalization]{.vocab}, and when it is a
universal quantifier phrase, we call it a [universal generalization]{.vocab}.

Unfortunately, Carnap does not yet support parsing problems for PL, of the
sort we did for SL in Unit 02. Below are several multiple choice questions.
Each problem involves a formula. I strongly encourage you to pull out a piece
of paper and a pencil, and parse each formula into a tree.

```{.QualitativeProblem .MultipleChoice points=10}
22 The formula '∀xF(x) ∧ G(x)' is a
| universal generalization
| existential generalization
| *conjunction
23 The formula '∀x(F(x) ∧ G(x))' is a
| *universal generalization
| existential generalization
| conjunction
24 The formula '¬∃x(F(x) → G(x))' is a
| universal generalization
| existential generalization
| *negation
| conditional
25 The formula '∃x(F(x) ∨ G(x))' is a
| universal generalization
| *existential generalization
| disjunction
```

::: youtube
<https://youtu.be/LAQK4OBpd1Y>
:::

## Informal Notation

Our conventions for informal notation remain the same, and remain in force.
So, for example,

:::displayed
-   ∀(x)(F(x) ∧ G(x) → H(x) ∨ I(x))
:::

is informal notation for,

:::displayed
-   ∀(x)((F(x) ∧ G(x)) → (H(x) ∨ I(x)))
:::

Note that quantifier phrases, like negations, function as *prefixes*.
Like negations, they do not introduce a surrounding pair of parentheses:

:::displayed
-   ¬P, [(¬P)]{.xed}
-   ∀xF(x), [(∀xF(x))]{.xed}
:::

And, like negations, they only get to be the main connective when they are all
the way out front of the entire formula.

## Scope 

A complex formula can have several connectives and quantifier phrases. One
is the *main connective*, and it governs the whole
sentence. But also, each connective or quantifier phrase is the main
connective of some part of the formula, and it governs that part of the
sentence. 

For example, in the sentence,

:::displayed
-   P ∧ Q → R ∨ S
:::

the '→' is the main connective for the whole sentence, the '∧' is the main
connective of the antecedent, 'P ∧ Q', and the '∨' is the main connective of the
consequent, 'R ∨ S'.

We call *the part of a sentence or formula for which a connective or quantifier phrase is the main connective* the [scope]{.vocab} of that connective.

Scope
:   The [scope]{.vocab} of a connective or quantifier phrase is the part of
    the formula for which it is the main connective.

So the *scope* of '∧' in 'P ∧ Q → R ∨ S' is 'P ∧ Q', and the scope of '→' is the entire sentence, 'P ∧ Q → R ∨ S'.

We can use the concept of scope to describe the difference between these two sentences:

:::displayed
-   ¬P → Q
-   ¬(P → Q)
:::

In the first, the scope of the negation is just the antecedent, '¬P'.
In the second, the scope of the negation is the entire sentence, '¬(P → Q)'.

And we can use the concept of scope to describe the difference between these two formulas:

:::displayed
-   ∀xF(x) → G(x) 
-   ∀x(F(x) → G(x))
:::

In the first, the scope of the quantifier is just the antecedent, '∀xF(x)'.
In the second, the scope of the quantifier is the entire formula, '∀x(F(x) → G(x))'.

```{.QualitativeProblem .MultipleChoice points=10}
26 In the formula, '¬(P∧Q)', the scope of the '¬' is:
| *'¬(P∧Q)'
| 'P∧Q'
| '¬P'
27 In the formula, '¬P∧Q', the scope of the '¬' is:
| '¬(P∧Q)'
| 'P∧Q'
| *'¬P'
28 In the formula, 'F(x)↔∀xG(x)', the scope of '∀x' is:
| 'F(x)↔∀xG(x)'
| *'∀xG(x)'
| 'G(x)'
29 In the formula, '∀x(F(x)↔G(x))', the scope of '∀x' is:
| *'∀x(F(x)↔G(x))'
| '∀xF(x)
| '(F(x)↔G(x))'
```

::: {.youtube}
<https://youtu.be/NKqbAiBiH80>
:::

``` {.Translate .FOL .Exact points="10"}
30 AxH(x): What is the scope of the '∀x' in 'P∨∀xH(x)'?
31 EyF(y): What is the scope of the '∃y' in '∃yF(y)∨∀xH(x)'?
32 Ey(F(y)\/AxH(x)): What is the scope of the '∃y' in '∃y(F(y)∨∀xH(x))'?
33 AyExF(x): What is the scope of the '∀y' in '∃z∀y∃xF(x)'?
```

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.34-37.mp4)
:::

## Scope and Binding

Quantifier phrases [bind]{.vocab} occurrences of variables that in are within their scope.
For example, in this formula, the quantifier phrase '∀x' binds all three occurrences of the variable 'x':

:::displayed
-   ∀x(F(x) ↔ G(x))
:::

But in this formula, the quantifier phrase '∀x' only binds the first two occurrences of 'x':

:::displayed
-   ∀xF(x) ↔ G(x)
:::

It does not bind the last occurrence of 'x', in 'G(x)', because that occurrence is not within its scope.

A quantifier phrase can only bind occurrences of *its* variable: 
 '∀x' can only bind occurrences of 'x'; 
 '∃y' can only bind occurrences of 'y'.
So, in this formula, the quantifier phrase '∃z' only binds the occurrences of 'z', not the occurrence of 'x':

:::displayed
-   ∃z(F(x) ∨ G(z))
:::

And a quantifier phrase cannot bind an occurrence of a variable 
 that *is already bound* by another quantifier phrase.
For example, in this formula, the quantifier phrase '∃x' does not bind the 'x' in 'G(x)',
 because it is already bound by the quantifier phrase '∀x': 

:::displayed
-   ∃x(F(x) ∧ ∀xG(x))
:::

What do I mean by "already"? 
How do we know what *order* the quantifiers bind in?
Quantifiers bind in the order that the formula is constructed,
 syntactically, by our rules.
So, again, it can be helpful to think about this in terms of trees:

:::illustration
![Tree for ∃x(F(x) ∧ ∀xG(x))](https://dsanson.github.io/logic-materials/img/ExKFxAxGx.png)
:::

Working our way up the syntactic tree for '∃x(F(x) ∧ ∀xG(x))', at an early
stage, the '∀x' gets attached to 'G(x)', forming '∀xG(x)'. At this point, both
of those occurrences of 'x' are bound by the '∀x'. So, when we reach the top
of the tree, where '∃x' is added, those occurrences of 'x' are already bound.

So, to summarize and make precise:

Bound variables
:   A quantifier phrase [binds]{.vocab} every occurrence of the variable that
    it quantifies over, that is within its scope, and that isn't already bound
    by another quantifier phrase.

Finally, two more definitions:

Free
:   A variable occurrence that is not bound is [free]{.vocab}

So, the first occurrence of 'x' in this formula
is free, while the second and third occurrences are bound:

:::displayed
-   F(x) ∧ ∃[x]{.wavy}G([x]{.wavy})
:::

Sentence
:   A formula with no free variable occurrences is a [sentence]{.vocab}

Recall we don't call the formula F(x), 'x is cosmic' a *sentence*,
 because it isn't true or false, full stop,
 but only true or false relative to an assignment of some value to the variable *x*.
That's because, in this formula, 'x' occurs free.
On the other hand, 'x' doesn't occur free in the formula, ∀xF(x): 'Every x is such that x is cosmic'.
So this formula is true or false, full stop, and it is a sentence.

Recall we don't call the formulas "sentences", 
 because they aren't true or false, full stop,
 but only true or false relative to an assignment of some value to the variable *x*.

For example, this formula is only true or false relative to an assignment of some value to the variable 'x':

:::displayed
-   I(x): x is in Illinois
:::

This is true when the value of 'x' is Watterson Towers, but false when the value of 'x' is the Epcot Center.

This is because, in this formula, 'x' occurs free.
When 'x' is bound by a quantifier, we get a sentence, which is true or false full stop:

:::displayed
-   ∃xI(x): Something is in Illinois
:::


```{.QualitativeProblem .MultipleChoice points=10}
34 'F(x)∧G(x)' is
| a sentence but not a formula
| *a formula but not a sentence
| both a formula and a sentence
35 '∃xF(x)∧G(x)' is
| a sentence but not a formula
| *a formula but not a sentence
| both a formula and a sentence
36 '∃xF(x)∧∃xG(x)' is
| a sentence but not a formula
| a formula but not a sentence
| *both a formula and a sentence
```

:::hint
Note that every sentence is a formula, but not every formula is a sentence. So
for each of these questions, the first option, 'a sentence but not a formula',
can be eliminated.
:::

:::solution
::: youtube
<https://youtu.be/VEsDYjx7BOo>
:::
:::


## Instances

:::wrapper
:::soasticky
| F:  is flat.
| G:  is real.
| a:  Kansas
| b:  Earth
:::

This argument is valid:

::: standardform
-   F(a): Kansas is flat.
-   ∃xF(x): Something is flat.
:::

The premise is an [instance]{.vocab} of the conclusion.
The conclusion says that *something* is flat.
The premise says that *Kansas* is flat.
Since Kansas counts as something, the conclusion follows from the premise.

A bit more formally, '∃xF(x)' says that, for at least one value of 'x', 'F(x)'
is true. And 'F(a)' says that 'F' is true of Kansas. So, since 'F' is true of
Kansas, 'F(x)' is true for at least one value of 'x'.

This argument is not valid:

::: standardform
-   F(a): Kansas is flat.
-   ∀xF(x): Everything is flat.
:::

Again, the premise is an [instance]{.vocab} of the conclusion.
The conclusion says that *everything* is flat.
The premise says that *Kansas* is flat.
So the premise tells us that *one* thing is flat,
 but not that *all* things are flat.

Again, a bit more formally, '∀xF(x)' says that, for *every* value of 'x',
'F(x)' is true. 'F(a)' tells us that 'F' is true of *one* value of 'x', but we
can't infer from this that 'F' is true of *every* value of 'x'.

This argument is valid:

::: standardform
-   ∀xF(x): Everything is flat.
-   F(a): Kansas is flat.
:::

This time, the conclusion is an [instance]{.vocab} of the premise. The premise tells us that 'F(x)' is true for *every* value of 'x'.
So it follows that 'F' is true of Kansas.

But this argument is not valid:

::: standardform
-   ∃xF(x): Something is flat.
-   F(a): Kansas is flat.
:::

Again, the conclusion is an [instance]{.vocab} of the premise. But this time, the premise only tells us that 'F(x)' is true of *at least one* value of 'x'. It gives us no reason to believe that it is true of *Kansas* in particular.

:::

We will understand the *logic* of generalizations in terms of
 this relationship between generalizations and instances.

To construct an \[instance}{.vocab} of a generalization, you remove the
quantifier phrase and uniformly replace the once-bound variable occurrences
with a term.

For example, starting with the generalization,

::: displayed
-   ∀x(F(x) ∧ G(x))
:::

we first remove the quantifier phrase,

::: displayed
-   (F(x) ∧ G(x))
:::

This frees both 'x's, which were once bound by the '∀x'. So we replace both of those 'x's with a term:

::: displayed
-   (F(a) ∧ G(a))
-   (F(b) ∧ G(b))
-   (F(c) ∧ G(c))
-   (F(y) ∧ G(y))
-   (F(z) ∧ G(z))
:::

Remember, a [term]{.vocab} is a constant or variable. So we can replace the
'x's with a constant, like 'a', or a variable, like 'y'. Also, we can replace
the 'x's with *any* term, and 'x' is a term. So we can replace the 'x's with
'x's:

::: displayed
-   (F(x) ∧ G(x))
:::

Our replacement must be *uniform*. That is, we can't replace some of the 'x's
with one term, and other 'x's with another term. So these are not instances of
our generalization:

:::{.displayed}
-   [(F(a) ∧ G(b))]{.xed}
-   [(F(x) ∧ G(y))]{.xed}
:::

There are a couple of complications. First, you must make sure that you *only*
replace the variables that were bound by the quantifier phrase you've removed. For
example, if our generalization is:

::: displayed
-   ∃y(F(a) → G(y))
:::

we can only replace the 'y', not the 'a', because the 'a' isn't a variable
that was bound by '∃y'. So this is not an instance:

::: {.displayed} 
-   [F(b) → G(b)]{.xed}
:::

But these are all instances:

::: displayed
-   F(a) → G(a)
-   F(a) → G(b)
-   F(a) → G(x)
:::

This can get confusing when there are overlapping quantifier
phrases:

::: displayed
-   ∀x(F(x) → ∃xG(x))
:::

The 'x's in '∃xG(x)' are not bound by '∀x'. So, when constructing instances,
 they cannot be replaced. Only the 'x' in 'F(x)' gets replaced:

::: displayed
-   F(a)→∃xG(x)
-   F(b)→∃xG(x)
-   F(x)→∃xG(x)
-   F(y)→∃xG(x)
-   [F(a)→∃aG(a)]{.xed}
-   [F(b)→∃xG(b)]{.xed}
-   [F(y)→∃yG(y)]{.xed}
:::

There is a second complication, also caused by quantifier phrases with
overlapping scope. Consider:

:::displayed
-   ∀x(F(x) → ∃y(G(y) ∧ H(x)))
:::

The main connective is the '∀x'. So we remove it:

:::displayed
-   F(x) → ∃y(G(y) ∧ H(x))
:::

Both 'x's are now free, and we can replace them with any term we want:

:::displayed
-   F(a) → ∃y(G(y) ∧ H(a))
-   F(b) → ∃y(G(y) ∧ H(b))
-   F(x) → ∃y(G(y) ∧ H(x))
-   F(z) → ∃y(G(y) ∧ H(z))
:::

But there is one term that we can't use:

:::{.displayed} 
-   [F(y) → ∃y(G(y) ∧ H(y))]{.xed}
:::

Notice that, when replace that second 'x' with 'y', it gets "captured" by the
quantifier, '∃y', and so is bound, not free. When constructing an instance,
if you choose to replace the once-bound variables with another variable, you
must make sure that the new variable *remains free*, and is *not captured* by
another quantifier.

```{.QualitativeProblem .MultipleSelection points=10}
37 Select all of the instances of the generalization, '∃xF(x)'.
| *'F(a)'
| '∃aF(a)'
| *'F(x)'
38 Select all of the instances of the generalization, '∃x(F(x)∨G(x))'?
| *'F(a)∨G(a)'
| 'F(a)∨G(b)'
| 'F(b)∨G(a)'
| *'F(x)∨G(x)'
| *'F(y)∨G(y)'
| 'F(x)∨G(y)'
39 Select all of the instances of the generalization, '∀x(F(x)∨G(a))'?
| 'F(a)∨G(b)'
| *'F(b)∨G(a)'
| *'F(a)∨G(a)'
| *'F(x)∨G(a)'
| 'F(a)∨G(x)'
40 Select all of the instances of the generalization, '∀x∃y(F(x)→G(y)∨G(x))'?
| *'∃y(F(x)→G(y)∨G(x))'
| *'∃y(F(a)→G(y)∨G(a))'
| '∃y(F(y)→G(y)∨G(y))'
| '∃x(F(y)→G(x)∨G(y))'
| *'∃y(F(z)→G(y)∨G(z))'
```

::: {.youtube}
<https://youtu.be/Q7lsLOu4_yI>
:::

::: {.youtube }
<https://youtu.be/0C1CE8wBl-8>
:::


``` {.Translate .FOL .Exact points="10"}
41 F(a),F(b),F(c),F(d),F(e),F(v),F(w),F(y),F(z): Provide an instance of the generalization, '∀xF(x)', that does not involve the variable 'x'
42 F(a)/\G(a), F(b)/\G(a), F(c)/\G(a), F(d)/\G(a), F(e)/\G(a), F(v)/\G(a), F(w)/\G(a), F(y)/\G(a), F(z)/\G(a): Provide an instance of the generalization, '∀x(F(x)/\G(a))', that does not involve the variable 'x'
```

:::solution
![](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/R12.45-46.mp4)
:::

## Constructing a generalization from an instance

Now we flip the process from the previous section on its head, and consider
what happens when we want to construct a generalization from an instance.

Consider the sentence,

::: displayed
-   F(a) ∧ G(a)
:::

What generalizations is this an instance of? Here is one:

::: displayed
-   ∀x(F(x) ∧ G(x))
:::

Removing the quantifier frees both of the 'x's, which we can uniformly replace
with 'a's, getting us 'F(a) ∧ G(a)'. So 'F(a) ∧ G(a)' is an instance of this
generalization.

It is also an instance of these generalizations, for the same reason:

::: displayed
-   ∀y(F(y) ∧ G(y))
-   ∃x(F(x) ∧ G(x))
:::

What about this one?

::: displayed
-   ∃y(F(a) ∧ G(y))
:::

Yes: when we drop the quantifier phrase, '∃y', we are left with 'F(a) ∧ G(y)'.
We can then replace the 'y' with any term we like. Replacing it with 'a' gets
us 'F(a) ∧ G(a)'.

When you are constructing an instance, you need to *uniformly* replace the
once-bound variables with the same term. But when you flip that on its head,
and consider the process of generalizing from an instance, you are allowed to
pick and choose which terms to replace with a now-bound variable. This isn't
because there are two different underlying rules about what counts as an
instance. It's just because a uniform replacement, when moving from a
generalization to an instance, can look like "picking and choosing" when run
in reverse, from instance to generalization.

Although you can "pick and choose", you have to always pick instances of the
same term. You cannot replace both an 'a' and a 'b' with a bound variable. So
you can't generalize from the first formula below to the second:

:::{.displayed }
-   F(a) ↔ G(b)
-   [∀x(F(x) ↔ G(x))]{.xed}
:::

To see this, try to work it backwards: remove the quantifier phrase, '∀x'; you are now required to
*uniformly* replace the now-free 'x's. Replacing one of them with 'a' and the other with 'b' is not allowed.

Here is a weird example. 

::: displayed
-   F(a) ∨ G(a)
-   ∀x(F(a) ∨ G(a))
:::

Convince yourself that 'F(a) ∨ G(a)' is an instance of '∀x(F(a) ∨ G(a)': remove the quantifier phrase; now uniformly replace all the once-bound occurrences of 'x'. But there aren't any, so there is nothing to replace, leaving you with 'F(a) ∨ G(a)'.

So, when constructing a generalization from an instance, the process looks
like this:

-   Uniformly replace some or all or none(!) of the occurrences of a term in
    the formula with a variable. (Be sure to choose a variable that remains free, and doesn't get
    captured.)
-   Add a quantifier phrase over that variable to the beginning of the
    formula.


```{.QualitativeProblem .MultipleSelection points=10}
43 Select all of the generalizations that have 'F(a)' as an instance.
| *∀xF(x)
| *∀zF(z)
| ∀aF(a)
| *∃xF(a)
44 Select all of the generalizations that have '~(F(a)↔G(a))' as an instance.
| *'∀x~(F(a)↔G(a))'
| *'∀x~(F(x)↔G(a))'
| *'∀x~(F(x)↔G(x))'
| '∀x~(F(y)↔G(y))'
| *'∀y~(F(y)↔G(y))'
```

## Exercises

:::wrapper
:::soasticky
| F: is awesome
| G: is cool
| a: Asmodeus
| b: Baphomet
:::

```{.Translate .FOL points=10}
45 F(a) : Asmodeus is awesome
46 ExF(x) : Something is awesome
```

``` {.Translate .FOL .Exact points="10"}
47 ExF(x): What is the scope of '∃x' in '∃xF(x)'
```

```{.Translate .FOL points=10}
48 F(a)->ExF(x) : If Asmodeus is awesome, then something is awesome
49 AxF(x) : Everything is awesome
50 ~AxF(x) : Not everything is awesome
51 ExG(x) : Something is cool
52 Ex~G(x) : Something is not cool
53 ~G(b) : Baphomet is not cool
54 G(a)/\G(b) : Asmodeus and Baphomet are both cool
55 ~(F(a)\/F(b)),~F(a)/\~F(b): Neither Asmodeus nor Baphomet are awesome
```
:::

``` {.Translate .FOL .Exact points="10"}
56 ~(P->Q): What is the scope of '¬' in '¬(P→Q)↔R∨S'?
57 ~P: What is the scope of '¬' in '(¬P→Q)↔R∨S'?
58 AxF(x): What is the scope of '∀x' in 'G(x)→∀xF(x)'?
```

```{.QualitativeProblem .MultipleSelection points=10}
59 Which occurences of variables are bound by '∀x' in 'G(x)→∀xF(x)'?
| the occurrence of 'x' in 'G(x)'
| *the occurrence of 'x' in '∀x'
| *the occurrence of 'x' in 'F(x)'
```

``` {.Translate .FOL .Exact points="10"}
60 EyF(y): What is the scope of '∃y' in '∀x∃yF(y)→∀xF(x)'?
```

```{.QualitativeProblem .MultipleSelection points=10}
61 Which occurences of variables are bound by '∃y' in '∀x∃yF(y)→∀xF(x)'?
| the occurrence of 'x' in the first '∀x'
| *the occurrence of 'y' in '∃y'
| *the occurrence of 'y' in 'F(y)'
| the occurrence of 'x' in the second '∀x'
| the occurrence of 'x' in 'F(x)'
```

``` {.Translate .FOL .Exact points="10"}
62 AxF(x): What is the scope of '∀x' in '∀xF(x)→G(x)'?
```

```{.QualitativeProblem .MultipleSelection points=10}
63 Which occurences of variables are bound by '∀x' in '∀xF(x)→G(x)'?
| *the occurrence of 'x' in '∀x'
| *the occurrence of 'x' in 'F(x)'
| the occurrence of 'x' in 'G(x)'
```

``` {.Translate .FOL .Exact points="10"}
64 Az(F(z)\/G(z)): What is the scope of '∀z' in '∀z(F(z)∨G(z))'?
```

```{.QualitativeProblem .MultipleSelection points=10}
65 Which occurences of variables are bound by '∀z' in '∀z(F(z)∨G(z))'?
| *the occurrence of 'z' in '∀z'
| *the occurrence of 'z' in 'F(z)'
| *the occurrence of 'z' in 'G(z)'
```

``` {.Translate .FOL .Exact points="10"}
66 F(a)\/G(a),F(b)\/G(b),F(c)\/G(c),F(d)\/G(d),F(e)\/G(e),F(v)\/G(v),F(w)\/G(w),F(x)\/G(x),F(y)\/G(y): Provide an instance of '∀z(F(z)∨G(z))', using a term other than 'z'.
```

``` {.Translate .FOL .Exact points="10"}
67 EyG(y): What is the scope of '∃y' in '∀x(F(y)∧G(x)→∃yG(y))'?
```

```{.QualitativeProblem .MultipleSelection points=10}
68 Which occurences of variables are bound by '∃y' in '∀x(F(y)∧G(x)→∃yG(y))'?
| *the occurrence of 'y' in '∃y'
| the occurrence of 'x' in '∀x'
| the occurrence of 'y' in 'F(y)'
| *the occurrence of 'y' in 'G(y)'
| the occurrence of 'x' in 'G(x)'
```

``` {.Translate .FOL .Exact points="10"}
69 Ex(F(x)/\AxG(x)/\H(x)): What is the scope of '∃x' in '∃x(F(x)∧∀xG(x)∧H(x))'?
```

```{.QualitativeProblem .MultipleSelection points=10}
70 Which occurences of variables are bound by '∃x' in '∃x(F(x)∧∀xG(x)∧H(x))'?
| *the occurence of 'x' in '∃x'
| *the occurence of 'x' in 'F(x)'
| the occurrence of 'x' in '∀x'
| the occurrence of 'x' in 'G(x)'
| *the occurrence of 'x' in 'H(x)'
```

``` {.Translate .FOL .Exact points="10"}
71 F(a)/\AxG(x)/\H(a), F(b)/\AxG(x)/\H(b), F(c)/\AxG(x)/\H(c), F(d)/\AxG(x)/\H(d), F(e)/\AxG(x)/\H(e), F(v)/\AxG(x)/\H(v), F(w)/\AxG(x)/\H(w), F(y)/\AxG(x)/\H(y), F(z)/\AxG(x)/\H(z): Provide an instance of '∃x(F(x)∧∀xG(x)∧H(x))', replacing the bound 'x's with some term other than 'x'
```

```{.QualitativeProblem .MultipleSelection points=10}
72 Select all the generalizations that have 'F(z)' as an instance.
| *∀xF(x)
| *∀xF(z)
| *∃yF(y)
| *∃zF(z)
```

``` {.Translate .FOL .Exact points="10"}
73 AxG(x), AxG(a), EyG(y), EyG(a), EzG(z), EzG(a), EwG(w), EwG(a), EvG(v), EvG(a): Provide a generalization that has 'G(a)' as an instance.
```

``` {.Translate .FOL .Exact points="10"}
74 G(d) : Provide an instance of '∃yG(d)'.
```

``` {.Translate .FOL .Exact points="10"}
75 Ey(F(a)/\G(y)), Ey(F(b)/\G(y)), Ey(F(c)/\G(y)), Ey(F(d)/\G(y)), Ey(F(e)/\G(y)), Ey(F(v)/\G(y)), Ey(F(w)/\G(y)), Ey(F(x)/\G(y)), Ey(F(y)/\G(y)), Ey(F(z)/\G(y)) : Provide an instance of '∀x∃y(F(x)∧G(y))'.
```

``` {.Translate .FOL .Exact points="10"}
76 AxEy(F(x)/\G(y)), AxEy(F(a)/\G(y)), ExEy(F(x)/\G(y)), ExEy(F(a)/\G(y)), EwEy(F(w)/\G(y)), EwEy(F(a)/\G(y)), EwEy(F(w)/\G(y)), EwEy(F(a)/\G(y)), EzEy(F(z)/\G(y)), EzEy(F(a)/\G(y)), EzEy(F(z)/\G(y)), EzEy(F(a)/\G(y)), EvEy(F(v)/\G(y)), EvEy(F(a)/\G(y)), EvEy(F(v)/\G(y)), EvEy(F(a)/\G(y)): Provide a generalization that has '∃y(F(a)∧G(y))' as an instance.
```

```{.QualitativeProblem .MultipleSelection points=10}
77 Select all the generalizations that have '∃y(F(y)∧G(z))' as an instance
| *∀x∃y(F(y)∧G(x))
| *∃z∃y(F(y)∧G(z))
| ∀y∃y(F(y)∧G(y))
| *∃x∃y(F(y)∧G(z))
```

```{.QualitativeProblem .MultipleSelection points=10}
78 Select all the generalizations that have 'F(a)↔G(a)∨H(a)' as an instance.
| *∃y(F(a)↔G(y)∨H(a))
| *∃x(F(x)↔G(x)∨H(x))
| ∀x(F(x)↔G(y)∨H(z))
| *∀z(F(a)↔G(a)∨H(z))
```


<!-- vim: set ft=carnap :-->
