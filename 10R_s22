---
base-css:
-   https://carnap.io/shared/dsanson@gmail.com/sanson-book.css
-   https://cdn.plyr.io/3.6.8/plyr.css
js: 
-   https://cdn.plyr.io/3.6.8/plyr.polyfilled.js
-   https://carnap.io/shared/dsanson@gmail.com/logic-book.js
-   https://hypothes.is/embed.js
---

::: cover

# Derivations with '∧', '∨', and '↔︎'

![](http://reggienet.illinoisstate.edu/access/content/user/desanso/public/img/sniffing_dog.jpg){alt="drawing of a hound sniffing a scent"}

::: epigraph
For, says this ancient authority \[Chrysippus\], the dog in effect reasons as
follows: the animal either went this way or that way or the other; he did not
go this way and he did not go that; therefore, he went the other.

[Sextus Empiricus, reporting on the views of Chrysippus]{.source}
:::

:::

::: {.auto-tally}
:::

In this unit, we expand the system of derivation to include rules for
all of our connectives. The specific learning objectives for this unit
are:

a.  I can identify instances of all the basic rules of sentential logic
b.  I can complete simple derivations involving all the connectives
c.  I can complete more complicated derivations involving all the
    connectives


## New Rules

[Til now]{.newthought}, we have only considered derivations involving '→' and '¬'. 
But we have three more connectives: '∧', '∨', and '↔'. To handle these, we
introduce six more rules.

As we introduce these rules, remember: each rule is tied to its connective.
For example, MP and MT only work on conditionals. This is *not* an instance of
MP, and it is *not* valid:

:::{.standardform .xed}
-   P ∨ Q
-   P
-   Q :MP
:::

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
R10.1 Try to explain, as best you can, why this inference is not valid. What would be a situation in which the premises are true, but the conclusion is false? 
R10.2 Explain why this isn't an instance of MP.
```

The *connective* is an essential part of the pattern that defines the rule.
Remember, the rule is meant to be *obviously valid*. And that depends on the
meanings of the connectives. In fact, some philosophers, called
*inferentialists*, turn that idea on its head, and explain meaning in terms of
inference rules. The point is, the relationship between a connective and its
inference rules is intimate and monogamous. Don't go trying to stick a
conjunction into an MP. That will just cause problems.

## Addition (ADD)

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Addition (ADD)**

:::{.displayed .liveshapes}
| []{.P} ⊢ []{.P} ∨ []{.Q}
| []{.P} ⊢ []{.Q} ∨ []{.P}
:::
:::
:::

We introduce two rules for disjunction ('∨'). The first is **Addition (ADD)**:

:::{.standardform .liveshapes}
-   []{.P}
-   []{.P} ∨ []{.Q}
:::

(By the way, I've added a new feature. You can now click on any box or circle,
and edit its content. This is a good way to "play" with the pattern, and get a
feel for how it works.)

Actually, Addition comes in two forms. The first form is above. The second
form is:

:::{.standardform .liveshapes}
-   []{.P}
-   []{.Q} ∨ []{.P}
:::

Do you see how they differ? 

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
R10.3 Briefly explain how the two forms of ADD differ.
```

:::spoiler
In the first form, we add a disjunct to the right of our premise. So, from
'P', we infer 'P ∨ Q'. In the second form, we add a disjunct to the left of
our premise. So, from 'P', we infer 'Q ∨ P'.
:::

The rule ADD is intimately tied to the meaning of '∨'. Remember, '∨' expresses an
*inclusive* disjunction. If it were an exclusive disjunction, ADD would not be
valid.



```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
R10.4 Give your own example of an English instance of ADD. That is, choose two English sentences, and fit them into the argument form.
R10.5 Explain, as best you can, why ADD is valid.
R10.6 Briefly explain why the validity of ADD depends on the inclusivity of '∨'
```

:::spoiler

Here is an example:

::: standardform
-   Normal is in Illinois
-   Either Normal is in Illinois or I'm a rooster's uncle
:::

I do have a pet parrot, and my sister keeps chickens, but I am not a rooster's
uncle. Still, from the premise, that Normal is Illinois, we can safely infer
that *either* Normal is in Illinois *or* I'm a rooster's uncle.

Actually, I only recently learned that the phrase, "Well I'll be a [monkey's
uncle](https://en.wikipedia.org/wiki/Monkey%27s_uncle){target="_blank"
rel="noopener noreferrer"}' comes from the 1920s, and was used by creationists
to make fun of the idea that we share a common evolutionary ancestor with
monkeys. Upon reflection, I suppose I am a monkey's (very distant) uncle. And
I am also a rooster's (even more distant) uncle.

Happily, since the disjunction is inclusive, the discovery that I am a
rooster's uncle after all does not undermine the validity of the inference.
Given the premise, that Normal is in Illinois, we can safely infer that
either Normal is in Illinois or I'm a roosters uncle, without worrying about
whether or not it is true that I'm a roosters uncle. The premise by itself does all the
work needed to make the conclusion true.
:::

Another way to think about what is going on with ADD is to consider the truth
table for an argument of this form:

```{.TruthTable .Validity options="nocounterexample turnstilemark" points=10}
R10.7 P :|-: P\/Q
```

After you have completed the truthtable, examine it. On every row where 'P' is
true, 'P ∨ Q' is true too. When assessing the validity of this argument, the
truth value of 'Q' is irrelevant. It is literally just an add-on, a hanger-on,
a groupie. P's got this, and doesn't need Q's help.

Here is another example:

::: standardform
-   The state bird of Illinois is the Northern Cardinal
-   Either the state bird of Illinois is the Northern Cardinal or the
    President is constipated.
:::

I don't know anything about the current state of our President's digestion,
but I know that the state bird of Illinois is the Northern Cardinal. And so I
am confident that the conclusion of this argument is true too. 

My confidence in the truth of the disjunction has nothing to do with any
judgment about the President. I have *exactly the same* confidence in the
truth of the conclusion of this argument:

::: standardform
-   The state bird of Illinois is the Northern Cardinal
-   Either the state bird of Illinois is the Northern Cardinal or the state
    bird of Hawaii is the Emu.
:::

::: aside
As a matter of fact, the state bird of Hawaii is the
[Nene](https://en.wikipedia.org/wiki/Nene_(bird)){target="_blank"
rel="noopener noreferrer"}.
:::

So this is our first new rule, which we call **Addition (ADD)**.

```{.QualitativeProblem .MultipleSelection points=10}
R10.8 Which of the following follows, by ADD, from P?
| *P ∨ Q
| *Q ∨ P
| *P ∨ (R ↔ S)
| *¬(P ∧ Q) ∨ P
```

:::spoiler
Those are all instances of ADD! ADD lets you add *any sentence* to your
premise, to create a disjunction.

:::{.standardform .liveshapes}
-   [P]{.P}
-   [P]{.P} ∨ [Q]{.Q}
:::

:::{.standardform .liveshapes}
-   [P]{.P}
-   [Q]{.Q} ∨ [P]{.P}
:::

:::{.standardform .liveshapes}
-   [P]{.P}
-   [P]{.P} ∨ [(R ↔ S)]{.Q}
:::

:::{.standardform .liveshapes}
-   [P]{.P}
-   [¬(P ∧ Q)]{.Q} ∨ [P]{.P}
:::
:::

Here is an example of ADD in action:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" submission=none}
Ex1 Q, P\/Q->R :|-: R
|1.Show R
|2.  Q         :PR
|3.  P\/Q->R   :PR
|4.  P\/Q      :ADD 2
|5.  R         :MP 3,4
|:DD 5
```

Do you see how this derivation works? I need to find a way to reason to R. I
know that Q is true, and I know that, if either P or Q is true, then R is
true too. So I use ADD to infer, from Q, that P or Q. And then I use MP to
infer R.

:::soa
| P: Justin Fields will start.
| Q: Andy Dalton will start.
| R: The Bears will probably lose.
:::

Suppose I know that Andy Dalton will start for the
Bears. And suppose I know that, if either Justin or Andy starts, the Bears
will probably lose. Then I reason as follows:

::: proof
1.   [The Bears will probably lose]{.show}
2.   [Andy Dalton will start [PR]{.just}]{.indent}
3.   [Either Justin Fields or Andy Dalton will start [ADD 2]{.just}]{.indent}
4.   [If either Justin or Andy starts, the Bears will probably lose
     [PR]{.just}]{.indent}
5.   [The Bears will probably lose [MP 3,4]{.just}]{.indent}
6.   [DD 5]{.just} 
:::

And here is an example for you to try:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
R10.9 P->Q, P :|-: R\/Q
```

::: youtube
<https://youtu.be/u0mXFRb3GX4>
:::

:::

## Modus Tollendo Ponens (MTP)

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Modus Tollendo Ponens (MTP)**

:::{.displayed .liveshapes}
| []{.P}∨[]{.Q}, ¬[]{.P} ⊢ []{.Q}
| []{.P}∨[]{.Q}, ¬[]{.Q} ⊢ []{.P} 
:::
:::
:::

ADD is a rule for *getting* a disjunction when you need one. But when you
*have* a disjunction, and need to *use* it, you will use Modus Tollendo
Ponens (MTP).

'Modus Tollendo Ponens' is another funny Latin name. It's actually one of four
classical rules of inference, all named according to the same scheme. The full
names of Modus Ponens and Modus Tollens are actually:

-   *Modus Ponendo Ponens*, aka Modus Ponens
-   *Modus Tollendo Tollens*, aka Modus Tollens

'Modus' means "way" or "method". "Ponendo" means "by putting" or "by
asserting", and "tollendo" means "by taking" or "by denying".  "Ponens" and
"Tollens" mean "putting/asserting" and "taking/denying".

These full names are actually quite descriptive. With Modus Ponendo Ponens, you
*put forth* the consequent of the conditional, *by putting forth* its
antecedent. With Modus Tollendo Tollens, you *deny* the antecedent, *by
denying* its consequent.

And with Modus Tollendo Ponens, you get to *put forth* something, *by denying*
something:

:::{.standardform .liveshapes}
-   []{.P} ∨ []{.Q}
-   ¬[]{.P}
-   []{.Q}
:::

While MP and MT are quite sensitive to which part you "put forth" or "deny",
MTP is free and easy. If you have a disjunction, and you have the negation of
either of its disjuncts, you can infer the other disjunct. So, like Addition,
the rule has two forms:

:::{.standardform .liveshapes}
-   []{.P} ∨ []{.Q}
-   ¬[]{.Q}
-   []{.P}
:::

Suppose I'm looking for my phone, and I know that

::: displayed
-  Either it is in the bathroom or it is on my bed,
:::

I look in the bathroom, and it isn't there, so now I also know that

::: displayed
-  It is not in the bathroom,
:::

So I conclude:

::: displayed
-  It is on my bed.
:::

That's an instance of MTP:

:::{.standardform .liveshapes}
-   Either [it is in the bathroom]{.P} or [it is on my bed]{.Q}
-   It is not the case that [it is in the bathroom]{.P}
-   [It is on my bed]{.Q}
:::

The ancient logician [Chrysippus](https://en.wikipedia.org/wiki/Chrysippus)
describes a dog chasing a rabbit down a path. Reaching a fork in the path, the
dog sniffs one fork, and goes down the other fork **without sniffing**. This,
Chrysippus argued, shows that dogs use logic. The dog's inference was:

::: standardform
-   Either the rabbit went left or the rabbit went right
-   The rabbit didn't go left
-   The rabbit went right
:::

Again the basic idea is this: if you know that one or the other of two
disjuncts is true, and you know that it is not one, then you can infer that it
must be the other.

As the name "Modus Tollendo Ponens" suggests, this form of reasoning is in
some ways similar to Modus Ponens, and in some ways similar to Modus Tollens.
But MP and MT are rules for using *conditionals*. MTP is a rule for using
*disjunctions*.

```{.QualitativeProblem .MultipleSelection points=10}
R10.10 What follows, by MTP, from "It is raining or snowing" and "It is not snowing"?
| *It is raining
| It is not raining
| It is raining and not snowing
```

``` {.Translate .Exact points="10"}
R10.11 P/\Q : What follows, by MTP, from '(P ∧ Q) ∨ R' and '¬R'?
```

:::spoiler
Remember to hit <enter> to check your answer. In this case, the answer is
`P/\Q`.
:::

Here is an example of MTP in action:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" init=true submission=none}
Ex2 P\/Q, ~P\/~R, ~Q :|-: ~R
|1.Show ~R
|2.  P\/Q     :PR
|3.  ~Q       :PR
|4.  P        :MTP 2,3
|5.  ~P\/~R   :PR
|6.  ~~P      :DN 4
|7.  ~R       :MTP 5,6
|:DD 7
```

And here is an example for you to try:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
R10.12 P\/(Q\/R), ~P :|-: ~R->Q 
```

::: youtube
<https://youtu.be/TnuYD3N-88A>
:::

## The Missing Modus

I mentioned that there are *four* classic rules "Modus" rules. What is the
fourth?

The fourth has fallen out of fashion:

-   *Modus Ponendo Tollens*, the way of denying by asserting

This is a rule for *exclusive* disjunctions:

:::{.standardform .liveshapes}
-   []{.P} $\veebar$ []{.Q}
-   []{.Q}
-   ¬[]{.P}
:::

Again, order of disjuncts doesn't matter. You could also infer ¬[]{.Q} from
[]{.P}. 

Do you see why this rule only works for exclusive, and not inclusive,
disjunction? This rule has fallen out of fashion because exclusive
disjunction has fallen out of fashion, and is no longer treated as a basic
connective. But it's kind of sad,
because there is something satisfying about seeing all four moduses side by
side. 

Remember that 'P $\veebar$ Q' is truth-functionally equivalent to '¬(P ↔ Q)'. In the next chapter, we will introduce [derived rules]{.vocab}: extra
rules that you can enable by producing a derivation to prove that they are
valid. At that point, it will be possible to create a version of MPT that
looks like this:

:::{.standardform .liveshapes}
-   ¬([]{.P} ↔ []{.Q})
-   []{.P}
-   ¬[]{.Q}
:::

We will leave MPT in the dustbin of history.

:::


## Simplification (S)

We have two new rules for disjunctions: ADD and MTP. We also have two new
rules for conjunctions: S And ADJ. The rules for conjunctions are the simplest
rules of all. So simple that it can be confusing.

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Simplification (S)**

:::{.displayed .liveshapes}
| []{.P} ∧ []{.Q} ⊢ []{.P}
| []{.P} ∧ []{.Q} ⊢ []{.Q}
:::
:::
:::

Our first rule for conjunctions is **Simplification (S)**. The idea behind
Simplification is simple: from *both* P *and* Q, you can infer P by itself.
And you can also infer Q by itself. A conjunction asserts that *both*
conjuncts are true; so, from a conjunction, you can infer either conjunct
on its own.

In standard form, the rule looks like this:

:::{.standardform .liveshapes}
- []{.P} ∧ []{.Q}
- []{.P}
:::

And since you can just as well infer the other conjunct too, the rule has two
forms. The other form looks like this:

:::{.standardform .liveshapes}
- []{.P} ∧ []{.Q}
- []{.Q}
:::

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
R10.13 Briefly explain how the two forms of S differ.
```

For example, suppose you are looking for a big dog to play the role of
Secretariat in a biopic that you are directing. And suppose you know that,

::: displayed
-   Mr. Peanut Butter is a big dog and he is a golden lab.
:::

From this, you can infer that,

::: displayed
-   Mr. Peanut Butter is a big dog 
:::

So, here is your argument:

::: {.standardform}
-   Mr. Peanut Butter is a big dog and he is a golden lab.
-   Mr. Peanut Butter is a big dog 
:::

The inference is so obviously valid that you might struggle to see it as any
inference at all. But it is. You've gone from making a complex claim to a simpler claim. You've
inference a simpler piece of information from a more complex piece of
information. You can do this because of what 'and' means. If your complex
piece of information were a conditional or disjunction, this inference
wouldn't be any good.

When people first start learning derivations, they often try to think about
the process as a process of "breaking down" or "breaking apart" or
"simplifying" the premises. And they reach for their high school algebra tool
kit for manipulating formulas. This is not a very helpful way of thinking about
the application of rules like DN, MP, MT, or ADD. But it is *exactly* what we
are doing with S! Simplify freely! Break complicated things into their simple
parts! But *only* when you are working with conjunctions.

:::

### Adjunction

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Adjunction (ADJ)**

:::{.displayed .liveshapes}
| []{.P}, []{.Q} ⊢ []{.P} ∧ []{.Q}
:::
:::
:::

Simplification is a rule that lets you take apart conjunctions. Adjunction
lets you put them together. In standard form, it looks like this:

:::{.standardform .liveshapes}
-   []{.P}
-   []{.Q}
-   []{.P} ∧ []{.Q}
:::

For example,

::: standardform
-  Bojack is a horse.
-  Bojack is depressed.
-  Bojack is a horse and Bojack is depressed.
:::

A conjunction allows us to express, in a single claim, the fact that two
independent pieces of information are both true. Adjunction reflects this:
given two separate pieces of information, you are allowed to join them
together into a conjunction.

:::

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Adjunction (ADJ)**

:::{.displayed .liveshapes}
| []{.P}, []{.Q} ⊢ []{.P} ∧ []{.Q}
:::
:::
:::ruledisplay
**Simplification (S)**

:::{.displayed .liveshapes}
| []{.P} ∧ []{.Q} ⊢ []{.P}
| []{.P} ∧ []{.Q} ⊢ []{.Q}
:::
:::
:::

Here is a simple example, using both **S** and **Adjunction (ADJ)**:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" init=true submission=none}
 P/\Q :|-: Q/\P
|1.Show Q/\P
|2.  P/\Q   :PR
|3.  P      :S 2
|4.  Q      :S 2
|5.  Q/\P   :ADJ 3,4
|6.:DD 5
```

Here is a problem for you to try.

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
R10.14 P/\(P->Q) :|-: P/\Q 
```

::: youtube
<https://youtu.be/EesD8OIDaUQ>
:::

:::

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Addition (ADD)**

:::{.displayed .liveshapes}
| []{.P} ⊢ []{.P} ∨ []{.Q}
| []{.Q} ⊢ []{.P} ∨ []{.Q}
:::
:::
:::ruledisplay
**Adjunction (ADJ)**

:::{.displayed .liveshapes}
| []{.P}, []{.Q} ⊢ []{.P} ∧ []{.Q}
:::
:::
:::

Addition and Adjunction have similar names. They also have similar looking
conclusions. It is easy to confuse them. But they are very different rules.

Addition says that, given *one* sentence that you know to be true, you are free to **add** any other
sentence, whether true or false, to form a disjunction:

:::{.standardform .liveshapes}
-   []{.P}
-   []{.P} ∨ []{.Q}
:::

Adjunction says that, given *two* sentences you know to be true, you are free
to **join** them together, to form a conjunction:

:::{.standardform .liveshapes}
-   []{.P}
-   []{.Q}
-   []{.P} ∧ []{.Q}
:::

:::aside
**J** is for join! Ad**j**unction **joins** two premises together. Addition
takes one premise, and adds something to it.
:::

Tip: think of the "J" in ADJ as standing for "join". When you use ADJ, you are
*joining* two independently verified pieces of information into a single
claim. When you use ADD, you are just *adding* some extraneous piece of
information on, as a disjunct, to an independently verified piece of
information.

:::stickywrapper
:::soasticky
| P: I messed up
| Q: You messed up
:::

Suppose we know that *I messed up*. From this, I can infer, by ADD, that *at least one of us messed up*:

::: proof
5.   [P [PR]{.just}]{.indent}
6.   [P ∨ Q [ADD 5]{.just}]{.indent}
:::

We don't have to first figure out whether or not you messed up too. The fact
that I messed up is enough to make it true that at least one of us did. *That*
is Addition.

On the other hand, suppose we know that *I messed up*,
And then we discover that you messed up too.
From these two pieces of information, we can infer that we both messed up:

::: proof
5.   [P [PR]{.just}]{.indent}
6.   [Q [PR]{.just}]{.indent}
7.   [P ∧ Q [ADJ 5,6]{.just}]{.indent}
:::

*That* is Adjunction: we are *joining* together two pieces of information.

:::

Here is a problem for you to try, that requires you to keep track of the
difference between ADD and ADJ:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
R10.15 P, Q :|-: (P/\Q)\/W
```

::: youtube
<https://youtu.be/isEp4x_Ly_s>
:::

:::

## Rules for the Biconditional


Our rules for the biconditional are very similar to our rules for conjunction.
We have one rule that allows us to "take apart", and one that
allows us to "put together". 

### Biconditional-to-Conditional (BC)

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Biconditional-to-Conditional (BC)**

:::{.displayed .liveshapes}
| []{.P} ↔ []{.Q} ⊢ []{.P} → []{.Q}
| []{.P} ↔ []{.Q} ⊢ []{.Q} → []{.P}
:::
:::
:::

Biconditional-to-Conditional (BC) is the rule we use to take apart a biconditional.
If you think of a biconditional as two conditionals joined together, pointing
in opposite directions, BC lets us infer either of of those conditionals from
the biconditional. In standard form, we can infer the left-to-right
conditional:

:::{.standardform .liveshapes}
-   []{.P} ↔ []{.Q} 
-   []{.P} → []{.Q}  
:::

Or we can infer the right-to-left conditional:

:::{.standardform .liveshapes}
-   []{.P} ↔ []{.Q} 
-   []{.Q} → []{.P}  
:::

:::stickywrapper
:::soasticky
| S: Socrates is human
| R: Socrates is a rational animal
:::

For example, suppose we know that Socrates is human if and only if he is a
rational animal. And suppose we know that he is a rational animal. We can use
BC, followed by MP, to infer that he is human:

::: proof
5.   [S ↔ R [PR]{.just}]{.indent}
6.   [R → S [BC 5]{.just}]{.indent}
7.   [R [PR]{.just}]{.indent}
8.   [S [MP 6,7]{.just}]{.indent}
:::

One common mistake is to try to apply Modus Ponens or Modus Tollens directly to a
biconditional. That isn't allowed, because MP and MT only apply to
conditionals. When you have a biconditional, and you also have one of its
parts or the negation of one of its parts, you first need to use BC, then
apply MP or MT.

:::

Here is a problem for you to try:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
R10.16 P<->Q, R<->Q, P :|-: R
```

::: youtube
<https://youtu.be/FNbZRAExdiE>
:::

:::

### Conditionals-to-Biconditional (CB)

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Conditionals-to-Biconditional (CB)**

:::{.displayed .liveshapes}
| []{.P} → []{.Q}, []{.Q} → []{.P} ⊢ []{.P} ↔ []{.Q}
:::
:::
:::

Conditionals-to-Biconditional (CB) is the rule that lets us "put together" a
biconditional. In standard form, it looks like this:

:::{.standardform .liveshapes}
-  []{.P} → []{.Q}
-  []{.Q} → []{.P}
-  []{.P} ↔ []{.Q}
:::

Again, the basic idea is that a biconditional is really two conditionals put
together. So if you have both conditionals---the left-to-right conditional and
the right-to-left conditional---as premises, you can put them together into a
biconditional.

:::

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Biconditional-to-Conditional (BC)**

:::{.displayed .liveshapes}
| []{.P} ↔ []{.Q} ⊢ []{.P} → []{.Q}
| []{.P} ↔ []{.Q} ⊢ []{.Q} → []{.P}
:::
:::
:::ruledisplay
**Conditionals-to-Biconditional (CB)**

:::{.displayed .liveshapes}
| []{.P} → []{.Q}, []{.Q} → []{.P} ⊢ []{.P} ↔ []{.Q}
:::
:::
:::

Notice the mnemonic. "BC" is the rule that allows to you infer
from a biconditional ("B") to a conditional ("C"). Hence the order of letters in
the abbreviation of the rule's name: "BC". "CB" is the rule that allows you to infer
from two conditionals ("C") to a biconditional ("B"), hence "CB". Another way to help
remember this: always pronounce the 'to', even though it isn't part of the
abbreviation. Pronounce "BC" as "B *to* C", and pronounce "CB" as "C *to* B".

Suppose you are reading the syllabus for a course that includes lots of
homework and three exams, including one big final exam. As you read, you glean
two important pieces of information:

-    If you can score 90% or above on the final, you will get an A in the
     course.
-    You will get an A in the course only if you score 90% or above on the
     final.

From these two pieces of information, you can infer that,

-    You will get an A in the course if and only if you score 90% or above on
     the final.

:::{.soa .aside}
| P: You score 90% or above on the final
| Q: You get an A in the course
:::

::: proof
5.   [P → Q [PR]{.just}]{.indent}
6.   [Q → P [PR]{.just}]{.indent}
7.   [P ↔ Q [CB 5,6]{.just}]{.indent}
:::

That's what BC looks like in action. Here is a derivation that requires both BC and CB to complete:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
R10.17 P<->Q :|-: Q<->P
```

::: {.youtube}
https://youtu.be/VaKe3icXeqY
:::
:::

That example is a bit to clean to be instructive. So let's tackle
something more challenging.

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Addition (ADD)**

:::{.displayed .liveshapes}
| []{.P} ⊢ []{.P} ∨ []{.Q}
| []{.Q} ⊢ []{.P} ∨ []{.Q}
:::
:::
:::ruledisplay
**Modus Tollendo Ponens (MTP)**

:::{.displayed .liveshapes}
| []{.P}∨[]{.Q}, ¬[]{.P} ⊢ []{.Q}
| []{.P}∨[]{.Q}, ¬[]{.Q} ⊢ []{.P} 
:::
:::
:::ruledisplay
**Simplification (S)**

:::{.displayed .liveshapes}
| []{.P} ∧ []{.Q} ⊢ []{.P}
| []{.P} ∧ []{.Q} ⊢ []{.Q}
:::
:::
:::ruledisplay
**Adjunction (ADJ)**

:::{.displayed .liveshapes}
| []{.P}, []{.Q} ⊢ []{.P} ∧ []{.Q}
:::
:::
:::ruledisplay
**Biconditional-to-Conditional (BC)**

:::{.displayed .liveshapes}
| []{.P} ↔ []{.Q} ⊢ []{.P} → []{.Q}
| []{.P} ↔ []{.Q} ⊢ []{.Q} → []{.P}
:::
:::
:::ruledisplay
**Conditionals-to-Biconditional (CB)**

:::{.displayed .liveshapes}
| []{.P} → []{.Q}, []{.Q} → []{.P} ⊢ []{.P} ↔ []{.Q}
:::
:::
:::


```{.ProofChecker .Prop options="guides fonts indent tabindent resize" submission=none}
 P->(Q/\R), Q->(R/\P) :|-: P<->Q
|1.Show P<->Q
|2.  P->(Q/\R)   :PR
|3.  Q->(R/\P)   :PR
|4.  ???
```

What to do next? Often, it helps to think about what you need to complete the
problem, and work backward from there. To complete the problem, we need to get
$P\leftrightarrow Q$. And the only rule we have that is going to make that
happen is CB. So we need to get $P\rightarrow Q$, and then get
$Q\rightarrow P$, and then apply CB to $P\leftrightarrow Q$. Let's go ahead
and see what that looks like:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" submission=none}
 P->(Q/\R), Q->(R/\P) :|-: P<->Q
|1.Show P<->Q
|2.  P->(Q/\R)   :PR
|3.  Q->(R/\P)   :PR
|4.  P->Q        :???
|5.  Q->P        :???
|6.  P<->Q       :CB 4,5
|7.:DD 6
```

Of course, this isn't yet a proper solution. Lines (4) and (5) aren't justified.
And there isn't any rule we can apply to (2) or (3) to get lines (4) or (5).
Still, when you know what you need, and you can't figure out how to get it, a
good trick is to write it down as a show line:

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" submission=none}
 P->(Q/\R), Q->(R/\P) :|-: P<->Q
|1.Show P<->Q
|2.  P->(Q/\R)   :PR
|3.  Q->(R/\P)   :PR
|4.  Show P->Q 
|5.    P         :AS
|6.    Q         :???
|7.  :CD 6
|8.  Show Q->P
|9.    Q         :AS
|10.    P        :???
|11.  :CD 10
|12.  P<->Q       :CB 4,8
|13.:DD 6
```

Here, I transformed the two sentences I knew I needed into show lines, and,
since they are both conditionals, I outlined conditional derivations for each
one. Of course, this is still not done, since (6) and (10) are unjustified.
But both of those subderivations can be completed, at which point we will have a
complete derivation. Can you work it out?

```{.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
R10.18 P->(Q/\R), Q->(R/\P) :|-: P<->Q
|1.Show P<->Q
|2.  P->(Q/\R)   :PR
|3.  Q->(R/\P)   :PR
|4.  Show P->Q 
```

::: {.youtube}
https://youtu.be/UFRJ194wq0A
:::


## All the Rules

These are the six new rules. Together with MP, MT, and DN, that gives
us 9 rules total:

:::{.flex}
:::ruledisplay
**DN**

::: {.standardform .liveshapes .clean}
-   []{.P}
-   ¬¬[]{.P}
:::
::: {.standardform .liveshapes .clean}
-   ¬¬[]{.P}
-   []{.P}
:::
:::

:::ruledisplay
**MP**

::: {.standardform .liveshapes .clean}
-   []{.P}→[]{.Q}
-   []{.P}
-   []{.Q}
:::
:::

:::ruledisplay
**MT**

::: {.standardform .liveshapes .clean}
-   []{.P}→[]{.Q}
-   ¬[]{.Q}
-   ¬[]{.P}
:::
:::

:::ruledisplay

**MTP**

::: {.standardform .liveshapes .clean}
-   []{.P}∨[]{.Q}
-  ¬[]{.P}
-   []{.Q}
:::
::: {.standardform .liveshapes .clean}
-   []{.P}∨[]{.Q}
-  ¬[]{.Q}
-   []{.P}
:::
:::

:::ruledisplay

**ADD**

::: {.standardform .liveshapes .clean}
-   []{.P}
-   []{.P}∨[]{.Q}
:::
::: {.standardform .liveshapes .clean}
-   []{.P}
-   []{.Q}∨[]{.P}
:::
:::

:::ruledisplay

**S**

::: {.standardform .liveshapes .clean}
-   []{.P}∧[]{.Q}
-   []{.P}
:::
::: {.standardform .liveshapes .clean}
-   []{.P}∧[]{.Q}
-   []{.Q}
:::
:::

:::ruledisplay

**ADJ**

::: {.standardform .liveshapes .clean}
-   []{.P}
-   []{.Q}
-   []{.P}∧[]{.Q}
:::
:::

:::ruledisplay

**BC**

::: {.standardform .liveshapes .clean}
-   []{.P}↔[]{.Q}
-   []{.P}→[]{.Q}
:::
::: {.standardform .liveshapes .clean}
-   []{.P}↔[]{.Q}
-   []{.Q}→[]{.P}
:::
:::

:::ruledisplay

**CB**

::: {.standardform .liveshapes .clean}
-   []{.P}→[]{.Q}
-   []{.Q}→[]{.P}
-   []{.P}↔[]{.Q}
:::
:::
:::

You need to *know* these rules. It is not enough to know *of* these rules,
and then look them up every time you need to use them. You need to be
able to use them as needed, which requires understanding them, and remembering
them.

## Strategies

Solving a derivation is like solving a puzzle. I've given you three methods
(DD, CD, and ID) and 9 rules (DNI, DNE, MP, MT, MTP, ADD, S, ADJ, BC, and
CB). Your task is to discover a path from the premises to the conclusion,
only using these methods and rules. 

There will *always* be more than one path available. Some will be long and
winding. Some will be surprisingly quick. If you are stuck, I can show you a
path. But the best path is the one you find for yourself.

If you understand the rules and methods, and spend time working through
several derivations, you will start to discover helpful strategies. In this
way, getting good a derivations is like getting good at checkers
or chess, or even tic-tac-toe. 

The first time you played tic-tac-toe, how did it go? Someone drew up a board,
told you the rules, and challenged you to a game. Probably, you lost that
first game. You kinda knew the rules. But you had no idea how to play. With
practice, you mastered the rules. And then you discovered the strategies. If
you played it enough, you got to where you could never lose.

Learning derivations is like that. You are learning the rules. Once you have
those down, with practice, you will start discovering the strategies.

The [Supplement](10S) to this chapter contains lots of strategic advice. I
encourage you to make use of it!

:::

## What Next?

-   [Exercises](10E)
-   [Mastery Check](10M)
-   [Supplements](10S)

<!-- vim: set ft=carnap :-->
