---
base-css:
-   https://carnap.io/shared/dsanson@gmail.com/sanson-book.css
-   https://cdn.plyr.io/3.6.8/plyr.css
js: 
-   https://cdn.plyr.io/3.6.8/plyr.polyfilled.js
-   https://carnap.io/shared/dsanson@gmail.com/logic-book.js
-   https://hypothes.is/embed.js
---

::: cover

# Truth and Countermodels

:::

::: {.auto-tally}
:::


In this unit, we learn how to use models to explore the logical 
properties of sentences and arguments in Predicate Logic. The
specific learning objectives for this unit are:

a.  I can construct a model to show that a sentence is not a logical
    truth in Predicate Logic
b.  I can construct a model to show that two sentences are not logically
    equivalent in Predicate Logic
c.  I can construct a model to show that an argument is not valid in
    Predicate Logic

## Meaning and Truth

Consider a sentence in our symbolic language, e.g.,

::: {.displayed}
-   ∀x(F(x)→G(x))
:::

Is this sentence true or false? 

That question doesn't quite make sense as it stands. Aside from the connective, '→', and the
quantifier, '∀x', the sentence is just a string of meaningless symbols. So
it's not (yet) the sort of thing that can be true or false. Before it can be
true or false, we need to assign *meanings* to predicate letters, 'F' and 'G'. But how do we do this?

One way is to provide a scheme of abbreviation, and correlate the meanings of
'F' and 'G' with the meanings of predicates in English. Let's try this.

Here is a first attempt:

::: soa
| F: is a tove
| G: is slithy
:::

This attempt fails, because 'slithy' and 'tove' are *nonsense words*, and have
no meaning. They come from
Lewis Carrol's poem
[Jabberwocky](https://www.poetryfoundation.org/poems/42916/jabberwocky). Since
'slithy' and 'tove' are meaningless, they cannot be used to give meaning to
'F' and 'G'. 

Indeed, the English translation of our symbolic sentence, using this scheme of
abbreviation, is also meaningless
nonsense, and not the sort of thing that can be true or false:

::: {.displayed}
-   All toves are slithy
:::

Here is a second attempt. This time, we make sure to avoid predicates that are
nonsense in English:

::: soa
| F: is a oenophile
| G: is creepy
:::

This is better. But I suspect you may not know what the word 'oenophile'
means. If so, you won't know the meaning assigned to 'F' by this scheme of
abbreviation. So you won't know how to assess the truth of the sentence,

::: displayed
-   Every oenophile is creepy.
:::

Here is a third attempt. This time, we make sure to avoid predicates that are
nonsense, and avoid predicates whose meanings we don't know:

:::soa
| F: is a frog
| G: is at least 2mm long
:::

This is better. We all know what the word 'frog' means, and we know what the
phrase, 'at least 2mm long' means. So we know how to assess the truth
value of the sentence,

::: {.displayed}
-   Every frog is at least than 2mm long
:::

How exactly to do we go about figuring out whether or not this is true? We can
search the web for facts about frog
length.

According to [wikipedia](https://en.wikipedia.org/wiki/Paedophryne_amauensis),
*P. amauensis*, the shortest known frog (and shortest known vertebrate!) in
the world, averages 7.7mm in "snout-to-vent length". But that's the average
length of a full-sized adult. So the smallest individual frog is presumably
shorter than that.

If that doesn't settle the matter, we can read scientific research articles on
frogs. But if that doesn't work, we have to figure it out for ourselves, by
going out into the world and measuring frogs.

How exactly does that last part work? And how is it related to *knowing the
meaning* of the word 'frog'? Imagine yourself, standing in a pond, knee deep
in mud, with a net. You dip the net into the muck, and rinse away the mud.
Left in your net is a tiny squirming creature. Now you need to figure out
whether or not it is a frog, and, if it is, whether or not it is less than 2mm
long.

Let's focus on just the first part: figuring out whether or not it is a frog.
Earlier, I said that we all know what the word 'frog' means. But what,
exactly, is the meaning of a word like 'frog'? Here is one compelling picture:
the *meaning* of the word 'frog' is a *rule for sorting things*. Specifically,
it is a rule for sorting things into two categories: the *frogs* and the
*non-frogs*.
So, on this picture, to know the meaning of 'frog' is to know how to sort
things in this way. In other words, to know what 'frog' means is to be able to
distinguish frogs from non-frogs.

Can you do that? I know I can't. I don't know, without looking it up, [whether
or not a toad is a
kind of frog](https://en.wikipedia.org/wiki/Toad). So, faced with a tiny
squirming creature, I'm going to hesitate: is it a frog or a toad? If it is a
toad, does that mean it's not a frog? This ignorance means that I will be very
bad at sorting things into frogs and non-frogs. Maybe you already knew that a
toad was a kind of frog. Still, unless you are an expert *amphibiologist*---a
biologist specializing in amphibians---I suspect your ability to sort things
into frogs and non-frogs has its limits.

Does that mean that only an expert amphibiologist can know the meaning of the word
'frog'? Or is it a reason to reject the idea that the meaning of a predicate
is a rule for sorting things? These are foundational questions about the
nature of meaning. They are above our paygrade in this course.

-----

Things have gotten messy. Let's step back and reconsider our original
question. In the immortal words of Bryan Colangelo, we need to [find a new
slant](https://www.washingtonpost.com/news/early-lead/wp/2018/06/07/bryan-colangelo-takes-heat-for-throwing-his-wife-under-the-bus-in-resignation/).

Our original question was: is '∀x(F(x)→G(x))' true or false? We noted that
this question is gets no purchase until we assign *meanings* to 'F' and 'G'.
We sought to do so by providing a scheme of abbreviation, correlating our
predicate letters with meaningful predicates in English. But that led us into a quagmire of
messy issues about the meanings of predicates in English. We need a different
strategy for assigning meanings to predicate letters, that does not rely on
the messiness of meanings in English.

PL is an artificial language. It is meant to be clean and simple,
free from vagueness and ambiguity. Our approach to meaning should likewise be
clean and simple, free from the messiness of a natural language.

We start by identifying the *meaning* of a word with its 
[extension]{.vocab}---the thing or things that it is about. That is:

1.  The extension of a constant (name letter) is an individual thing.
2.  The extension of a predicate letter is the set of things it is true of.
3.  The extension of a sentence letter is a truth value, T or F.

So the meaning of a constant, like 'a', is the *thing* that it names. If 'a'
is a name for the number 1, then the meaning of 'a' is the number one. If 'a'
is a name for the city of Chicago, then the meaning of 'a' is the city of
Chicago. To be clear, I don't mean that the meaning of 'a' is the *words* 'the
city of Chicago'. I mean that the meaning of 'a' is the city itself, the large
sprawling thing that you can visit, on the shore of Lake Michigan.

The meaning of a predicate letter, like 'F', is a set. For example, 'F' might
be assigned, as its meaning, the set of all frogs. Or it might be assigned, as
its meaning, the set of all odd numbers. Or it might be assigned, as its
meaning, the set: {Normal, Chicago, Springfield}.

Intuitively, the meaning of a predicate in English, like 'frog', is not just
the set of all frogs. Instead, it is an account of what a frog is, which gives
us a rule for sorting out the frogs from the
non-frogs. Call the set of all frogs the [extension]{.vocab} of the predicate
'frog'. Call the rule for sorting out the frogs from the non-frogs the
[intension]{.vocab} of 'frog'. A sophisticated theory of meaning might assign
an intension to each predicate, and allow that intension to determine its
extension. But our goal here is to keep things simple. So we just identify the
meaning of a predicate letter with its extension, and don't worry about
intensions.

----

Now we have a less messy account of meaning. So let's return to our question:
is '∀x(F(x)→G(x))' true or false? This question only makes sense *relative to*
an assignment of meanings to the predicate letters. For example:

:::model
| F: the set of all cities in Illinois
| G: the set of all cities in the USA
:::

On this assignment of meanings to 'F' and 'G', the sentence comes out true,
because everything that is in the set F is also in the set G. By contrast:

:::model
| F: the set of all cities in the USA
| G: the set of all cities in Illinois
:::

On this assignment, the sentence comes out false, because there are members of
the set F that are not members of the set G.

Or consider the sentence 'F(a)'. Is it true or false? To answer this question, we need to assign meanings to 'F' and 'a':

::: model
| F: { [Jeremiah](https://youtu.be/uy1x5pnPaCQ), Kermit,
  [Mr. Toad](https://en.wikipedia.org/wiki/Mr._Toad),
  [Keroppi](https://en.wikipedia.org/wiki/List_of_Sanrio_characters#Keroppi),
  [Dan'l Webster](https://twain.lib.virginia.edu/projects/price/frog.htm) }
| a: Kermit
| b: Mrs. Piggy
:::

Given these assignments, 'F(a)' is true, because the extension of 'a', Kermit,
is a member of set that is the extension of 'F'. On the other hand, 'F(b)' is
false, because the extension of 'b', Mrs. Piggy, is not a member of the
extension of 'F'.

In principle, we can assign an extension to every sentence letter, predicate
letter, and name letter in our language. We call this an
[interpretation]{.vocab} of our language. In practice, we can make do with
*partial* interpretations, just assigning extensions to whatever sentence
letters, predicate letters, and name letters are present in the sentences we
are considering.

An interpretation alone isn't enough to determine the truth value of every
sentence in PL. The interpretation tells you which things are in the
extension of each sentence letter, predicate letter, or name letter. But it
doesn't tell you what things exist. For example, consider this
interpretation:

::: model
| F: { John, Paul, Ringo, George }
:::

Is the sentence '∀xF(x)' true or false on this interpretation? The
interpretation tells us that John, Paul, Ringo, and George are all in F. But it doesn't
give us enough information to determine whether or not *everything* is F.
That's because it tells us which things are F, but doesn't tell us what
things there are.

For that, we need to specify a [domain]{.vocab}. A domain is a set of objects,
meant to represent the set of all the objects that exist. So here is an
interpretation together with a domain:

::: model
| Domain: { John, Paul, Ringo, George, Stuart }
| F: { John, Paul, Ringo, George }
:::

Relative to this interpretation and domain, '∀xF(x)' is false. This is because
Stuart is in the domain, but is not in F, so it is not true that everything is
in F.

Here is another interpretation and domain:

::: model
| Domain: { John, Paul, Ringo, George }
| F: { John, Paul, Ringo, George }
:::

Relative to this interpretation and domain, '∀xF(x)' is true, because
everything in the domain is also in F.

A domain together with an interpretation is called a [model]{.vocab}. A model gives us
everything that we need to determine the truth or falsehood of a sentence in
PL.

So let's consider '∀x(F(x)→G(x))' again. Here is a model on which this sentence is
true:

::: model
| Domain: { John, Paul, Ringo, George, Stuart }
| F: { John, Paul }
| G: { John, Paul, Ringo, George }
:::

Can you see why the sentence is true on this model? Informally, the sentence
'∀x(F(x)→G(x))' says that every F is G. And, as you can see, each thing that
is in the extension of 'F' is also in the extension of 'G'.

We can construct a model on which the sentence is false by putting something
into the extension of 'F' that is not also in the extension of 'G'. For
example:

::: model
| Domain: { John, Paul, Ringo, George, Stuart }
| F: { John, Stuart }
| G: { John, Paul, Ringo, George }
:::

## Variables and Domains

Note that an interpretation does not specify extensions for variables. An
interpretation is a device for fixing meanings, and unlike name letters and
predicate letters, variables don't have fixed meanings.

Prior to this class, most of your experience with variables likely came from
algebra. Note that in algebra, the question is never,

:::displayed
-   Is '$2x+3=5$' true?
:::

instead, the question is,

::: displayed
-   $2x+3=5$. Solve for $x$.
:::

What is it to "solve for $x$"? To solve for $x$ is to find the value of $x$
that makes the formula true. In this case, that value is the number
1. So your answer is $x=1$. But we could just as well ask you to provide a value
for $x$ that makes the sentence *false*. In that case, you might answer with
$x=2$, or $x=3$, or any of several other equally good answers.

The point is that, with the algebraic formula '$2x+3=5$', the value of the
variable, $x$, is left open, allowing us to consider what happens when we
*assign* some value or other. When we assign $x$ the value 1, the formula is
true; when we assign $x$ the value 2, the formula is false.

The same goes for formulas with free variables in PL. Our
interpretation leaves open the value of $x$, so, when presented with the
formula,

::: {.displayed}
-   F(x) ∧ G(x)
:::

we can consider what happens to this formula when we assign different values
to $x$.

For example, consider the model,

::: {.model}
| Domain: { Bobby Seale, Huey Newton, Angela Davis }
| F: { Bobby Seale, Huey Newton }
| G: { Huey Newton, Angela Davis }
:::

'F(x)∧G(x)' is true on this model when we assign Huey Newton as the value
of x, but is false when we assign Angela Davis as the value of x.

## Calculating Truth

Given a model, we can determine the truth value of a complex sentence. How
exactly we do that depends on the main connective of the sentence:

Sentence Letters
:   If the sentence is a sentence letter, then the truth value of the
    sentence in the model is the extension assigned by the model.

Name-Predicate Sentences
:   If '$F$' is a predicate and '$a$' is a name letter, then '$F(a)$' is true in
    the model just in case the extension of '$a$' is a member of the extension
    of '$F$'.

Variable-Predicate Formulas
:   If '$F$' is a predicate and '$x$' is a variable, then '$F(x)$' is neither
    true nor false in the model, full stop. Instead, it true or false in the
    model *relative to an
    assignment of some value from the domain* to the variable '$x$'. It is
    true in the model relative to an assignment just in case the assigned value is in the extension of '$F$'.

Truth-Functional Sentences
:   If the main connective of a sentence is '¬', '→', '∧',
    '∨', or '↔', then the truth value of the sentence is given by
    the characteristic truth table for that connective.

Quantificational Sentences
:   '$\forall x...x...x...$' is true just in case '$...x...x...$' is true no
    matter what object in the domain you assign as the value for the free
    occurrences of '$x$'. '$\exists x...x...x...$' is true just in case
    '$...x...x...$' is true on at least one assignment of an object from the
    domain to the free occurrences of '$x$'.

Suppose the domain is the set of all natural numbers. Here is a partial
interpretation:

::: model
| Domain: the set of all natural numbers
| F: { 1,2,3,4 }
| G: { 2,4,6,8 } 
| P: F
| Q: T
| a: the number 1
| b: the number 4
:::

``` {.QualitativeProblem .MultipleChoice points="10"}
R15.1 Is 'F(a)' true or false on this interpretation?
| *true
| false
R15.2 Is 'G(a)' true or false on this interpretation?
| true
| *false
R15.3 Is 'P∨F(b)' true or false on this interpretation?
| *true
| false
R15.4 Is 'F(a)→G(a)' true or false on this interpretation?
| true
| *false
R15.5 Is '∃xF(x)' true or false on this interpretation?
| *true
| false
R15.6 Is '∀xG(x)' true or false on this interpretation?
| true
| *false
```

## Countermodels and Logical Truth

Recall the distinctions we made in [Chapter 7](07R). There we distinguished
sentences that are [truth-functionally true]{.vocab}, [truth-functionally
false]{.vocab}, and [truth-functionally contingent]{.vocab}. A
truth-functionally true sentence is one that is true on every row of the truth
table: it is a logical truth in SL. A truth-functionally false
sentence is one that is false on every row of the truth table: it is a logical
falsehood in SL. And a truth-functionally contingent sentence is one that is
true on some rows, false on others. So it is neither a logical truth, nor a
logical falsehood, in SL.

Each row of a truth table represents a model: a possible assignment of
extensions to the sentence letters. So a truth-functionally true sentence is
*true on every model*; a truth-functionally false sentence is *false on every
model*; a truth-functionally contingent sentence is *true on at least one
model* and *false on at least one model*. These definitions can be generalized
to PL. Specifically:

Logical Truth in PL
:   A sentence is a [logical truth in predicate logic]{.vocab} iff it is true
    in every model.

Logical Falsehood in PL
:   A sentence is a [logical falsehood in predicate logic]{.vocab} iff it is false
    in every model.

Logical Contingency in PL
:   A sentence is a [logical falsehood in predicate logic]{.vocab} iff it is
    true on at least one model and false on at least one model.

In SL, we could organize all possible models into a neat finite table. But in
PL, we have to consider infinitely many different models. So there is no way
to present them all in neat finite table.

Instead, we will focus on looking for countermodels to logical truth:

Countermodels
:   A [countermodel to the logical truth of a sentence]{.vocab} is a model in which that sentence
    is false.

If we can find a countermodel for a given sentence, that shows that the
sentence is *not* true in all models, and so is *not* a logical truth in
predicate logic.

Here is an example. Your task is to show that the sentence is not a logical
truth, by constructing a countermodel. For technical reasons, we restrict
ourselves to models whose domains are natural numbers. Watch the video to see
a walk through of the solution.

``` {.CounterModeler .Simple counterexample-to=tautology points="10"}
R15.7 ~(F(a)/\F(b))
```

<div class=youtube>
<https://youtu.be/hK3GHTBhe4Q> 
</div>

Remember, the goal is to make the sentence false. Since it is a negation, that
means we need to make the negated sentence, 'F(a) ∧ F(b)', true. We
begin with a domain that contains just a single object, the number 0. And we
begin an interpretation that has the extension of 'F' empty, and with the
extensions of 'a' and 'b' both set to the number 0.

To make ‘F(a) ∧ F(b)’ come out true, then, we need to ensure that the
thing referred to by 'a' is in the extension of 'F'. So let's do that:

::: model
| Domain: { 0 }
| F: { 0 }
| a: 0
| b: 0
:::

Note that on this interpretation, 'b' is just another name for the number 0,
so the referent of 'b' is also in the extension of 'F'. This means that, on
this model, 'F(a) ∧ F(b)' is
true. Which means that its negation is false. Success!

That's a funky model. It asks us to imagine a situation where only one thing
exists, the number zero, and it has two names. You might prefer constructing a
model that has more objects in the domain. And you might prefer constructing a
model in which 'a' and 'b' refer to different things. Here is such a model:

::: model
| Domain: { 0,1 }
| F: { 0,1 }
| a: 0
| b: 1
:::

Can you verify that '¬(F(a)∧F(b))' is false in this model, too?

Let's work through another example:

``` {.CounterModeler .Simple counterexample-to=tautology points="10"}
R15.8 Ax(F(x)\/G(x))
```

<div class=youtube>
<https://youtu.be/EmnLFUa8SBk>
</div>

The sentence says 'Everything is either F or G'. We want a model that makes
this *false*. The simplest model is this:

::: model
| Domain: { 0 }
| F: { }
| G: { }
:::

In this model, the domain contains just a single object, the number 0. The
extension of 'F' is the empty set. In other words, 'F' isn't true of anything.
Likewise for 'G'. So how does '∀x(F(x)∨G(x))' fare in this model? For it to be
true in the model, 'F(x)∧G(x)' has to be true, no matter what object from the
domain we assign to the variable 'x'. Since there is only one object in our
domain, there is only one assignment to consider:

-   'F(x)∨G(x)', where x is assigned the number 0 as its value.

On this assignment, 'F(x)' is false, and 'G(x)' is false, so 'F(x)∨G(x)' is
false. So our original sentence, '∀x(F(x)∨G(x))', is false, since 'F(x)∨G(x)'
is not true for every value we might assign to 'x'.

Again, this model is a bit funky. Once again, only one thing is in the domain.
You might prefer a model with a larger domain. This model also works as a
countermodel:

::: model
| Domain: { 0,1,2,3 }
| F: { 1,2 }
| G: { 0,2 }
:::

In this model, it is not true that everything is either F or G, because the
number 3 is neither F nor G.

But I encourage you to start small and simple. Begin with a domain that has
just one thing in it, the number 0. And begin with the extensions of your
predicates empty. Expand your domain, and fill those extensions as necessary,
until you find something that works as a countermodel.

Here are some more examples. In each case, your task is to construct a
countermodel, that is, a model in which the sentence is false:

``` {.CounterModeler .Simple counterexample-to=tautology points="10"}
R15.9 F(a)->F(c)
```

<div class=youtube>
<https://youtu.be/qbkWxs_992s>
</div>

``` {.CounterModeler .Simple counterexample-to=tautology points="10"}
R15.10 ~AxF(x)
```

<div class=youtube>
<https://youtu.be/i0fvWo1oCDQ>
</div>

``` {.CounterModeler .Simple counterexample-to=tautology points="10"}
R15.11 Ax(F(x)->G(x))
```

<div class=youtube>
<https://youtu.be/Y05KRK4_8mQ>
</div>

It bears repeating: we can use countermodels to show that a sentence is *not*
a logical truth in PL. But we cannot use models to show that a
sentence *is* a logical truth in PL. Consider the sentence,
'∀x(F(x)→F(x))'. This sentence *is* a logical truth in
PL. If you try to construct a countermodel, you will fail. But
you can't *show* this by trying to construct a countermodel and failing. Your
failure doesn't show that there is no countermodel. All it shows is that, if
there is a countermodel, you weren't able to find it.

## Countermodels and Validity

We can also consider the truth or falsity of several sentences at once, in a
single model. This means that we can use models to think about *validity in
PL*:

Validity in Predicate Logic
:   An argument is [valid in PL]{.vocab} iff there is no model
    in which all of its premises true and its conclusion is false.

Again, this is a generalization of our definition of [truth-functional
validity]{.vocab} from [Chapter 8](08R). If the sentences that make up our argument contain only sentence letters, and no predicate letters, then
we can determine whether or not the argument is valid in predicate logic by
constructing a truth table. Each row of the truth table represents a model.
So, if there is no row of the table on which all the premises are true and the
conclusion false, then there is no model in which all the premises are true
and the conclusion false, so the argument is valid.

But when the sentences contain predicate letters and quantifiers, matters get more
complicated. We have infinitely many different models to consider, and there
is no way to present them all in a neat finite table.

What we can do, as before, is look for *countermodels*:

Countermodels for Validity
:   A [countermodel to validity]{.vocab} for an argument is a model in which
    all of the argument's premises are true and its conclusion is false.

We can show that an argument is *not* valid in PL by producing a
countermodel to its validity.

Here is an example:

``` {.CounterModeler .Validity points="10"}
R15.12 Ax(F(x)->G(x)), ExG(x) :|-: ExF(x)
```

::: {.youtube}
<https://youtu.be/9ku5F0AbU8c>
:::

Here is an English version of the argument:

::: {.standardform}
-   Every frog is green
-   Something is green
-   Something is a frog
:::

We need to construct a model that makes the premises true, but the conclusion
false. Let's start with the simplest possible model:

::: model
| Domain: { 0 }
| F: { }
| G: { }
:::

This model has a single thing in its domain, and the extension of each
predicate is empty. We need our model to make the conclusion, '∃xF(x)', false.
That means that, whatever else we do, we need to keep the extension of 'F'
empty:

::: model
| Domain: { 0 }
| F: { <keep empty!> }
| G: { }
:::

And we know that we need to make the second premise, '∃xG(x)', true. That
means that we need to put *at least* one thing into the extension of 'G':

::: model
| Domain: { 0 }
| F: { <keep empty!> }
| G: { 0 }
:::

Now look at the first premise. We need '∀x(F(x)→G(x))' to be true. In
other words, we need 'F(x) → G(x)' to be true, for every value of x in
the domain. Right now, the only value x can take is 0, since that’s the
only thing in our domain. When we plug in 0 as the value of x,
'F(x) → G(x)' comes out true, because its antecedent, 'F(x)', is false.
So we have successfully discovered a countermodel to the validity of the
argument!

::: model
| Domain: { 0 }
| F: {  }
| G: { 0 }
:::

In this model, it is true that every F is G (because nothing is F). And it is
true that something is G (because the number 0 is). But it is false that something is
F. So this shows that our argument is not valid.

Here are some more examples to work through. Again, in each case, your task is
to construct a countermodel to the validity of the argument:

```{.CounterModeler .Validity points=10}
R15.13 F(a), F(b) :|-: AxF(x)
```

<div class=youtube>
<https://youtu.be/_4GFL1qtR0s>
</div>

```{.CounterModeler .Validity points=10}
R15.14 ExF(x), ExG(x) :|-: Ex(F(x)/\G(x))
```

<div class=youtube>
<https://youtu.be/0Yedf20XtOc>
</div>

```{.CounterModeler .Validity points=10}
R15.15 Ex(F(x)/\G(x)), Ex(G(x)/\H(x)) :|-: Ex(F(x)/\H(x))
```

<div class=youtube>
<https://youtu.be/uaofAwr7tUs>
</div>




<!-- vim: set ft=carnap :-->
