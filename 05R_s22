---
base-css:
-   https://carnap.io/shared/dsanson@gmail.com/sanson-book.css
-   https://cdn.plyr.io/3.6.8/plyr.css
js: 
-   https://cdn.plyr.io/3.6.8/plyr.polyfilled.js
-   https://carnap.io/shared/dsanson@gmail.com/logic-book.js
-   https://hypothes.is/embed.js
---

::: {.auto-tally}
:::

::: cover
# Inference Rules and Direct Derivations

![Modus Ponies](http://reggienet.illinoisstate.edu/access/content/user/desanso/public/img/modus_ponies.png){title="Modus
Ponies" alt="A visual pun: two ponies arranged in the form of Modus Ponens."} 

::: epigraph
"The only way to rectify our reasonings is to make them as tangible as those of
the Mathematicians, so that we can find our error at a glance, and when there
are disputes among persons, we can simply say: Let us calculate, without
further ado, to see who is right." 

[[Gottfried Leibniz](https://iep.utm.edu/?p=17335){target="_blank"
rel="noopener noreferrer"}, Letter to Johann Friedrich, 1679]{.source}
:::
:::


## Introduction

An argument represents your starting point---your premises---and an ending
point---your conclusion. But it doesn't represent the *reasoning* that takes
you from that starting point to that ending point, the path from those premises to that
conclusion.

We call that path a [proof]{.vocab}: a line of reasoning that *establishes*
that a given argument is in valid.
And we represent a proof with a [derivation]{.vocab}:
 a series of steps, each an instance of a carefully defined valid 
 [inference rule]{.vocab}, 
 that takes us from the premises to the conclusion.

In this chapter, we carefully define four valid inference rules:
 [Double Negation Elimination (DNE)]{.vocab}, 
 [Double Negation Introduction (DNI)]{.vocab}, 
 [Modus Ponens (MP)]{.vocab},
 and [Modus Tollens (MT)]{.vocab}.

We then put these rules to use, and learn how to construct simple direct
derivations.

In later chapters,
 we will explore more complicated derivations, and
 we will define additional inference rules,
 involving our other connectives.

Your learning objectives for this chapter are:

a.  I can identify instances of the three inference rules, DN, MP, and MT.
b.  I can apply the three inference rules, DN, MP, and MT.
c.  I can complete simple direct derivations

## Proofs and Arguments

Here is a mini-lecture.
It is about 5 minutes long.
It introduces the idea of a proof,
 the idea of a derivation,
 and the idea of an inference rule.
You don't *need* to watch the mini-lecture. 
But you may find that it helps you follow the reading.

(When I made this video, this content was part of "Unit 4", instead
of "Unit 5".
When I mention, in the video, what we cover in "Unit 4", I am talking about
what we now cover in this chapter, Unit 5.)

:::solution
:::youtube
<https://youtu.be/Ur0SzN406Y8>
:::
:::

A [direct derivation]{.vocab} is the simplest kind of derivation or proof.
It starts from the premises, 
 and proceeds, step by step, 
 from those premises, to the conclusion. 
In a properly constructed derivation,
 each step is valid:
 that is, each step is guaranteed to preserve truth.
Since each step is guaranteed to preserve truth,
 the entire journey is guaranteed to preserve truth.

A properly constructed derivation is like a pipe or wire through which
validity flows:
 *Water* flows through a properly constructed *pipe*. 
 *Electricity* flows through a properly installed *wire*.
 *Validity* flows through a properly constructed *derivation*.
A poorly constructed pipe fails to transmit water from point A to point B,
 either because it has a broken or clogged section,
 or it is missing a section,
 or it doesn't extend from A to B.
A poorly constructed wire fails to transmit electricity from point A to point
B,
 again either because it has a broken or missing section,
 or because it fails to connect A to B.
And a poorly constructed derivation fails to transmit validity,
 either because it has a missing or broken step,
 or because it fails to extend from the premises to the conclusion.

:::illustration
![Water running through a
pipe](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/homer-water.gif){alt="Homer
Simpson has constructed an elaborate pipe that directs water leaking through
the ceiling out the mail slot in the front door."}
:::

How do we ensure that each step in a derivation is valid?
We require that each step be an instance of one of our [inference rules]{.vocab},
 and we make sure that each inference rule is valid.

So, before we look more closely at derivations, 
 let's introduce our first four inference rules:
 Double Negation Elimination (DNE), 
 Double Negation Introduction (DNI), 
 Modus Ponens (MP), 
 and Modus Tollens (MT).

## Double Negation Introduction and Double Negation Elimination

Here is another mini-lecture, introducing our first two rules,
 Double Negation Introduction
 and Double Negation Elimination.

:::solution
::: youtube
<https://youtu.be/k5O1qop2FE4>
:::
:::



Consider these two arguments:

:::standardform
-   She loves me.
-   It is not the case that she doesn't love me.
:::

:::standardform
-   It is not the case that she doesn't love me.
-   She loves me.
:::

:::aside
:::illustration
![She loves me, she loves me
not...](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/img/she_loves_me.gif){alt="An animation showing Yogi Bear pulling petals off of a daisy."}
:::
:::

You are probably familiar with [the old game](https://en.wikipedia.org/wiki/He_loves_me..._he_loves_me_not){target="_blank"
rel="noopener noreferrer"}:
 you pluck a petal off a flower,
 and, with each petal,
 you alternate between saying, 'she loves me',
 and 'she loves me not'.
The truth is revealed when you pluck the last petal.

If 'she loves me' is in fact true, then
 your first sentence, when you pluck the first petal, is true,
 and your second sentence, 'she loves me not', is false,
 and your third sentence, 'she loves me', is true,
 and so on.
If 'she loves me' is in fact false, then
 your first sentence, when you pluck the first petal, is false,
 and your second sentence, 'she loves me not', is true,
 and your third sentence, 'she loves me', is false,
 and so on.

We can represent this with a table:

::: itt
   She loves me   She loves me not   She loves me   She loves me not   ...
  -------------- ------------------ -------------- ------------------ -----
        T                F                T                F           ...
        F                T                F                T           ...
:::

The first row represents how the game plays out when 'P' is actually true.
The second row, when 'P' is actually false.
Of course, 
 the pretense of the game is that you don't know which row you are on
 until you pluck that last petal,
 and discover the truth.

As a logic professor, I prefer a slightly tweaked version of the game.
Instead of alternating between 'she loves me' and its negation, 
 I like to add an *additional* negation each time I pluck a petal.
That way, the game is more exciting and less repetitive.

And, as a logic professor, I prefer to use canonical English,
 rather than the stilted and stylized English of the traditional game:

:::example
-   She loves me.
-   It is not the case that she loves me.
-   It is not the case that it is not the case that she loves me.
-   It is not the case that it is not the case that it is not the case that she loves me.
-   and so on...
:::

And, as a logic professor, 
 I prefer to play the game in SL rather than English.
I would hate it if the truth of her love
 were lost to some unnoticed lexical or structural ambiguity.
So I use 'P' for 'She loves me', 
 and as I pluck each petal, I say:

:::example
-   P (pronounced "pee")
-   ¬P ("not pee")
-   ¬¬P ("not not pee")
-   ¬¬¬P ("not not not pee")
-   ¬¬¬¬P ("not not not not pee")
-   and so on...
:::

Everyone tells me I'm fun at parties.

My game is different from the traditional game.
In the traditional game, 
 you alternate between the same two sentences.
In my game, 
 with every petal, 
 I utter a *new* and *longer* sentence each time.
But at the level of truth values, 
 the two games are the same:
 just as your sentences alternate between true and false,
 my sentences also alternate between true and false.
For example, if 'P' is in fact true, then
 my second sentence, '¬P', is false,
 my third sentence, '¬¬P', is true,
 my fourth sentence, '¬¬¬P', is false,
 and so on.
And if 'P' is in fact false, then
 my second sentence, '¬P', is true,
 my third sentence, '¬¬P', is false,
 my fourth sentence, '¬¬¬P', is true,
 and so on.

Again, we can represent this with a table:

::: itt
   P   ¬P   ¬¬P   ¬¬¬P   ¬¬¬¬P   ¬¬¬¬¬P   ...
  --- ---- ----- ------ ------- -------- -----
   T   F     T     F       T       F      ...
   F   T     F     T       F       T      ...
:::

The first row represents how the game plays out when 'P' is true.
The second row, how the game plays out when 'P' is false.
As you can see, 
 my nontraditional game plays out the same as your traditional game.

Consider just the first three columns of my game:

::: itt
   P   ¬P   ¬¬P
  --- ---- -----
   T   F     T
   F   T     F
:::

The second column represents the negation of 'P'.
The third column represents the negation of '¬P',
 which is also the *double-negation* of 'P'.
When you negate a sentence,
 the truth value of the negation is
 always the opposite of the truth value of the sentence negated.
So when you *double-negate* a sentence,
 the truth value of the double negated sentence is
 always the same as the truth value of the sentence double-negated.

This gives us our first two rules of inference:

Double Negation Introduction (DNI)
:   Given any sentence, []{.P}, as your premise, 
    you can infer its double negation, ¬¬[]{.P},
    as your conclusion.

Double Negation Elimination (DNE)
:   Given the double negation, ¬¬[]{.P}, 
    of any sentence, []{.P}, as your premise, 
    you can infer that sentence, []{.P},
    as your conclusion.

Here is an instance of DNE, in English:

:::standardform
-   I don't not care.
-   I care.
:::

The premise is the double-negation of the conclusion, 'I care'.
So we know that the premise and the conclusion will always have the same truth
value.
So we know that this form of argument is guaranteed to preserve truth.
In other words, we know that this form of argument is valid.

If we use 'Q' for 'I care', we can translate the argument into SL:

:::standardform
-   ¬¬Q
-   Q
:::

Here is another instance of DNE in English:

:::standardform
-   It is not the case that you aren't wrong.
-   You are wrong.
:::

If we use 'W' for 'You are wrong', we can translate this argument into SL:

:::standardform
-   ¬¬W
-   W
:::

Again, the premise is the double-negation of the conclusion, 
 'You are wrong'.
So, again, we know that 
 the premise and conclusion 
 must always agree in truth value.
So we know that the argument must always preserve truth, and so is valid.

Here is the abstract form of DNE, in SL:

:::{.standardform .liveshapes}
-   ¬¬[]{.P}
-   []{.P} 
:::

Plug any sentence of SL into the box,
 and you get another instance of DNE,
 guaranteed to preserve truth,
 and so valid.

Time to introduce a new type of exercise.
Each of the following questions gives you a premise, 
 and asks you what follows from that rule by DNE.
Type in the correct sentence in SL to answer the question.

(As with translation exercises,
 you must type "enter" or "return" to check your answer,
 before then clicking "Submit" to submit your answer.)


``` {.Translate .Exact points="10"}
1 R: Suppose you have ¬¬R as a premise. What follows, by DNE?
```

:::solution
![solution to question 1](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/not_not_R.mp4)
:::


``` {.Translate .Exact points="10"}
2 P/\Q: Suppose you have ¬¬(P ∧ Q) as a premise. What follows, by DNE?
```

:::solution
![solution to 2](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNE_NNCPQ.mp4)
:::

No doubt you've been told, 
 at some point in your education, 
 to avoid double negatives.
That is a good rule of thumb for speaking and writing:
 better to say, 'Everyone is coming to my party',
 than 'Nobody is not coming to my party',
 even though the two sentences mean the same thing.
But this is terrible advice for doing logic.
We want to *explore* the *logic* of negation,
 and that includes the logic of *double negations*.
So, in this class, it is not wrong to not avoid double negations.

Here is an instance of Double Negation Introduction (DNI):

:::standardform
-   We are coping with the pandemic the best we can.
-   We aren't not coping with the pandemic the best we can.
:::

If we use 'P' to stand for 'We are coping with the pandemic the best we can',
 we can translate this into SL:

:::standardform
-   P
-   ¬¬P
:::

Instances of DNI are valid for the same reason that instances of DNE are
valid:
 the premise and conclusion must have the same truth value,
 so the argument is guaranteed to preserve truth.

Here is the general form of the rule:

:::{.standardform .liveshapes}
-   []{.P} 
-   ¬¬[]{.P}
:::

DNI is just like DNE, but the premise and conclusion are reversed.
DNE allows us to *eliminate* a double negation: hence its name!
DNI allows us to *introduce* a double negation, hence its name.

``` {.Translate .Exact points="10"}
3 ~~(P->Q): Suppose you have P → Q as a premise. What follows, by DNI?
```
:::solution
![Solution to 3](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNI_CPQ.mp4)
:::

``` {.Translate .Exact points="10"}
4 ~~(P /\ Q -> Q \/ R): Suppose you have P∧Q → Q∨R as a premise. What follows, by DNI?
```
:::solution
![Solution to 4](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNI_CKPQAQR.mp4)
:::

## Distinct but Logically Equivalent

This section is an aside. 
But it is an important aside, 
 addressing some common stumbling blocks
 when thinking about double negations.

A sentence and its double negation are [logically equivalent]{.vocab}:

Logical Equivalence
:   Two sentences, []{.P} and []{.Q}, are [logically equivalent]{.vocab}
    iff necessarily, they have the same truth value.

:::.aside
Remember, 'iff' is short for 'if and only if'.
:::

But a sentence and it double negation are *not the same sentence*.
The sentence, 'I don't not care' 
 *means the same thing as* 
 the sentence 'I care'. 
But they are *not the same sentence*.
The first is four words long;
 the second is two words long.

It is easy to confuse these two things,
 and fall into the trap of imagining that,
 since 'P' and '¬¬P' are *logically equivalent*,
 they are basically *the same sentence*,
 and so can be used interchangeably.

Our inference rules are *patterns*.
Whether or not an argument counts as an instance of a rule
 depends on whether or not the *sentences* fit the pattern.
This is an instance of DNI:

:::standardform
-   P
-   ¬¬P
:::

This is *not* an instance of DNI:

:::standardform
-   P
-   P
:::

When you are doing logic,
 you cannot simply *replace* an occurrence of '¬¬P' with 'P',
 and act as though it is the same sentence.

In Algebra,
 you learned that two *negatives* cancel each other out.
So you learned that $--x = x$.
And you learned to *simplify* algebraic expressions
 by *cancelling out* double negatives.
So, given $--(x + y) = 15$,
 you simplify it to $x + y = 15$.
You have done this so many times that it is probably
 an automatic habit:
 something you do without thinking.

Our negation symbol, '¬', 
 looks a lot like the sign we use to negate a number.
So you might find yourself extended the habits
 you learned in Algebra
 to these sentences in SL.
You might, withouth thinking,
 assume that the two negations "cancel each other out*,
 and so write '¬¬P' as 'P', 
 or write 'P ∧ ¬¬Q' as 'P ∧ Q'.

But that's a mistake:
 if your premise is '¬¬P', you have to write it as '¬¬P';
 if your premise is 'P ∧ ¬¬Q', you have to write it as 'P ∧ ¬¬Q'.
You cannot "cancel out" the two negations "in your head".

Again, we want to focus our *attention on*
 the *logic* of negations, including double negations.
You can't do this if you don't even *see* double negations,
 because your brain rushes to "cancel them out",
 before they even get written down.
So you must unlearn that habit,
 or, at least, learn not to apply it here.

## Rules as Patterns

DNI and DNE are patterns.
Given any sentence, you can use DNI to infer its double negation.
For example:

:::{.standardform .liveshapes}
-  [¬P]{.P}
-  ¬¬[¬P]{.P}
:::

Here, the conclusion is the triple negation of 'P'.
But it is also the double negation of '¬P',
 and that's why this counts as a legitimate instance of DNI.

Remember my version of "she loves me/she loves me not",
 and how I just keep on adding negations.
DNI and DNE allow you to add or remove negations,
 but always two at a time.

Note also that this is *not* and instance of DNI:

:::{.standardform .liveshapes}
-  P ∨ [Q]{.P}
-  ¬¬[Q]{.P}
:::

The rule says that, when applying DNI,
 your conclusion must be the double negation of your premise.
So when you apply DNI to this premise, it looks like this:

:::{.standardform .liveshapes}
-  [P ∨ Q]{.P}
-  ¬¬[(P ∨ Q)]{.P}
:::

There is no unstated extra provision,
 that allows you to apply DNI or DNE
 just to a *part* of your premise.

```{.QualitativeProblem .MultipleChoice points=10}
5 <div class="standardform"> <ul> <li>Q</li> <li>¬Q</li> </ul> </div>
| This is an instance of DNI
| This is an instance of DNE
| *This is not an instance of DNI or DNE
6 <div class="standardform"> <ul> <li>¬¬¬¬Q</li> <li>¬¬Q</li> </ul> </div>
| This is an instance of DNI
| *This is an instance of DNE
| This is not an instance of DNI or DNE
7 <div class="standardform"> <ul> <li>Q</li> <li>¬¬¬¬Q</li> </ul> </div>
| This is an instance of DNI
| This is an instance of DNE
| *This is not an instance of DNI or DNE
```

:::{.reaction .correct ex=7}
:::standardform
-   Q
-   ¬¬¬¬Q
:::

This is a valid argument, but it is not an instance of DNI.
The only possible instance of DNI from 'Q' as a premise is:

:::standardform
-   Q
-   ¬¬Q
:::

And the only possible instance of DNI that has '¬¬¬¬Q' as conclusion is:

:::standardform
-   ¬¬Q
-   ¬¬¬¬Q
:::

Note that this means that we can reason from 'Q' to '¬¬¬¬Q' in *two steps*,
 each an instance of DNI.
So the argument is valid,
 but proving that it is valid will require a derivation,
 because it is not an instance of one of our rules.
:::

```{.QualitativeProblem .MultipleChoice points=10}
8 <div class="standardform"> <ul> <li>(P∧Q)</li> <li>¬¬(P∧Q)</li> </ul> </div>
| *This is an instance of DNI
| This is an instance of DNE
| This is not an instance of DNI or DNE
9 <div class="standardform"> <ul> <li>¬¬(P ∧ Q ↔ Q ∨ R)</li> <li>(P ∧ Q ↔ Q ∨ R)</li> </ul> </div>
| This is an instance of DNI
| *This is an instance of DNE
| This is not an instance of DNI or DNE
10 <div class="standardform"> <ul> <li>P→Q</li> <li>P→¬¬Q</li> </ul> </div>
| This is an instance of DNI
| This is an instance of DNE
| *This is not an instance of DNI or DNE
```

:::{.reaction .correct ex=10}
This argument is not an instance of DNI:

:::standardform
-   P → Q
-   P → ¬¬Q
:::

As explained above, when you apply DNI to a premise,
 you must double negate the *entire premise*,
 not just a part of the premise.

This argument is valid,
 but we will have to prove that by constructing a derivation,
 since it is not an instance of one of our rules.
We won't have the tools needed to construct that derivation
 until the next chapter.
:::


``` {.Translate .Exact points="10"}
11 ~~(P->(Q\/R)): Suppose you have P → (Q ∨ R) as a premise. What follows, by DNI?
```

:::solution
![Solution to 11](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNI_CPAQR.mp4)
:::

``` {.Translate .Exact points="10"}
12 ~~P->(~~Q\/~~R): Suppose you have ¬¬(¬¬P → (¬¬Q ∨ ¬¬R)) as a premise. What follows, by DNE?
```

:::solution
![Solution to 12](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNE_NNbigmess.mp4)
:::

## Modus Ponens

Again, here is a video mini-lecture, 
 which you may find helps you follow the reading.

:::solution
::: youtube
<https://youtu.be/qJbHNMhxOUc>
:::
:::

So far, we have only considered rules involving negation.
In this section, we consider two rules that involve conditionals.

The first is called [Modus Ponens (MP)]{.vocab}.
Here is an instance of Modus Ponens in English:

:::standardform
-   If you are feeling sick, then you should stay home.
-   You are feeling sick.
-   You should stay home.
:::

Convince yourself that this argument is valid.

Let's break it down.

:::standardform
-   If [you are feeling sick]{.P .mpantecedent}, then [you should stay
    home]{.Q .mpconsequent}.
-   [You are feeling sick]{.P .mppremise}.
-   [You should stay home]{.Q .mpconclusion}.
:::

The first premise is a conditional. 
A conditional makes a hypothetical claim:
 *if* such and such hypothetical condition 
 expressed by the antecedent obtains, 
 *then* this other condition,
 expressed by the consequent
 also obtains.
Specifically,
 *if* you are feeling sick,
 *then* you should stay home.
the other premise tells us that the hypothetical condition does in fact
obtain:
 you are feeling sick.
So it follows that the condition expressed by the consequent also obtains:
 you should stay home.

Here is another instance of MP in English:

:::standardform
-   If [our winter is unusually cold]{.P .mpantecedent}, then [some of the less hardy plants die]{.Q .mpconsequent}.
-   [Our winter is unusually cold]{.P .mppremise}.
-   [Some of the less hardly plants die]{.Q .mpconclusion}.
:::

Again, this argument is valid, and for the same reason.
The conditional premise relates the two conditions,
 and says that
 *if* the condition expressed by the antecedent holds,
 *then* the condition expressed by the consequent holds.
The second premises says that the hypothetical condition---
 the condition expressed by the antecedent---
 does actually obtain.
From these two premises together,
 it follows that the condition expressed by the consequent obtains as well.

:::vaside
Refresher: 

| the [antecedent]{.vocab} of a conditional is the part that comes *before* the
  arrow;
| the [consequent]{.vocab} is the part that comes *after* the arrow.

The prefix 'ante' means *before*. When you play poker, the ante is the stake
put up *before* the deal. Since I'm a hipster, was into it before it was cool:
that is, my interest *ante*dates its being cool. An *ante*chamber or
*ante*room is a waiting room that you enter *before* you enter the main room.

The consequent is what *comes after*, in the sense of *following*, not
in time, but logically.
:::



Modus Ponens has an evil twin,
 an argument form that looks similar,
 but is *not* valid.
It is called [Affirming the Consequent]{.vocab}.
Here is an example:

:::{.standardform .exed}
-   If [you are feeling sick]{.P .mpconsequent}, then [you should stay
    home]{.Q .mpantecedent}.
-   [You should stay home]{.Q .mppremise}.
-   [You are feeling sick]{.P .mpconclusion}.
:::

Do you see how this argument makes the mistake
 of reading the conditional premise backwards?
The premise does not say that
 if you should stay home
 then you are feeling sick.
It says that
 if you are feeling sick
 then you should stay home.
We cannot infer from this that,
 since you should stay home,
 it must be that you are sick.
There are plenty of other possible reasons why it might be
 true that you should stay home:
 maybe today is a holiday, for example.


Here is another example of Affirming the Consequent:

:::{.standardform .exed}
-   If Fido is a cat, then Fido is a mammal.
-   Fido is a mammal.
-   Fido is a cat.
:::

Again, the argument is not valid.
The conditional premises says that
 if Fido is a cat,
 then Fido is a mammal.
It doesn't say that
 if Fido is a mammal,
 then Fido is a cat.
Suppose Fido is a dog:
 then both premises can be true,
 but the conclusion false.

::: stickywrapper
::: {.aside .sticky .flex}
:::ruledisplay
**Modus Ponens (MP)**

:::{.standardform .liveshapes}
-  [ ]{.P .mpantecedent} → [ ]{.Q .mpconsequent}
-  [ ]{.P .mppremise}
-  [ ]{.Q .mpconclusion}
:::
:::
:::ruledisplay
**Affirming the Consequent**

:::{.standardform .liveshapes .xed}
-   []{.P .mpconsequent} → []{.Q .mpantecedent}
-   []{.Q .mppremise}
-   []{.P .mpconclusion}
:::
:::
:::

We could call Modus Ponens "Affirming the Antecedent".
That is basically what 'Modus Ponens' means in Latin:
 'modus' means 'way';
 'ponens' means 'putting' or 'setting' or 'positing',
 or, in a logical context, 'affirming'.
So 'Modus Ponens' means, roughly,
 'the way of putting/positing/affirming'.
When you apply Modus Ponens, you have two premises:
 one is a conditional;
 the other affirms its antecedent.

By contrast, when you mistakenly apply Affirming the Consequent instead,
 you have two premises:
 one a conditional,
 and the other affirming the consequent.

:::illustration
![Hermione on the proper way to pronounce 'Modus
Ponens'](http://reggienet.illinoisstate.edu/access/content/user/desanso/public/img/leviosa.gif)
:::

Actually, the original full Latin name of the rule is 'Modus Ponendo Ponens':
 "the way of positing/affirming by positing/affirming".
When you apply Modus Ponens,
 your premise affirms the antecedent,
 and this entitles you to affirm the consequent.
This is the only *valid* rule that allows you to affirm by affirming,
 since Affirming the Consequent is not valid.

``` {.Translate .Exact points="10"}
13 Q: Suppose you have P → Q as one premise, and P as your other premise. What follows, by MP?
```

:::solution
![Solution to 13](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_MP_CPQ_P.mp4)
:::

``` {.Translate .Exact points="10"}
14 Q: Suppose you have Q → P as a premise. What other premise do you need, to apply MP?
```

:::solution
![Solution to 14](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/mp_MP_CQP.mp4)
:::

``` {.Translate .Exact points="10"}
15 R: Suppose you have P∧Q → R as one premise, and P∧Q as your other premise. What follows, by MP?
```

:::solution
![Solution to 15](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_MP_CKPQR.mp4)
:::

``` {.Translate .Exact points="10"}
16 R->Q: Suppose you have (R → Q) → R as a premise. What other premise do you need, to apply MP?
```

:::solution
![Solution to 16](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wp_CRCQR_MP.mp4)
:::

:::

## Modus Tollens

We have one more rule to introduce: [Modus Tollens (MT)]{.vocab}.
'Tollens', in Latin, means 'taking' or 'denying'.
And actually, the original full Latin name is 'Modus Tollendo Tollens':
 the way of taking/denying by taking/denying.

Here is an example:

:::standardform
-   If [the laws in your country are just]{.mtantecedent}, then [it is wrong to break them]{.mtconsequent}.
-   [It is]{.mtpremise} not [wrong to break the laws in your country]{.mtpremise}.
-   [The laws in your country are]{.mtconclusion} not [just]{.mtconclusion}.
:::

Do you see that this is valid?
One premise is a conditional.
It does not say that the laws in your country *are* just.
But it says that on the hypothesis that they are, 
 it is wrong to break them.
The other premise says that it is *not* wrong to break the laws:
 it denies or rejects the consequent.
But that means that the hypothetical condition,
 expressed by the antecedent,
 must not obtain:
 if it did, then the consquent would too.
So the laws in your country are not just.

Here is another example:

:::standardform
-   Kyrie can play in NYC only if he is vaccinated.
-   Kyrie is not vaccinated.
-   Kyrie cannot play in NYC.
:::

Remember how 'only if' works.
We can restate this argument as:

:::standardform
-   If Kyrie can play in NYC then he is vaccinated.
-   Kyrie is not vaccinated.
-   Kyrie cannot play in NYC.
:::

Again, one premise is a conditional.
Again, the other premise is the negation of the consequent.
Again, the conclusion is the negation of the antecedent.

Here is the pattern:

:::standardform
-   []{.P .mtantecedent} → []{.Q .mtconsequent}
-   ¬[]{.Q .mtpremise}
-   ¬[]{.P .mtconclusion}
:::


Modus Tollens also has an evil twin,
 called "Denying the Antecedent".
Here is an example:

:::{.standardform .xed}
-   If [Fido is a dog]{.mtconsequent} then [Fido is a mammal]{.mtantecedent}.
-   [Fido is]{.mtpremise} not [a dog]{.mtpremise}.
-   [Fido is]{.mtconclusion} not [a mammal]{.mtconclusion}.
:::

Do you see that this argument is not valid? 
Suppose Fido is a cat.
Then both premises are true, but the conclusion is false.

::: stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Modus Tollens (MT)**

:::{.standardform .liveshapes}
-   []{.P} → []{.Q}
-   ¬[]{.Q}
-   ¬[]{.P}
:::
:::

:::ruledisplay
**Denying the Antecedent**

::: {.standardform .liveshapes .xed}
-   []{.P} → []{.Q}
-   ¬[]{.P}
-   ¬[]{.Q}
:::
:::
:::

And can you see that once again,
 the mistake involves reading the conditional premise backwards?
It doesn't say that if Fido is a mammal, he is a dog.
It says that if he is a dog, he is a mammal.

``` {.Translate .Exact points="10"}
17 ~R: Suppose you have 'R → P' and '¬P' as your premises. What follows by MT?
```

:::solution
![Solution to 17](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_CRP_NP_MT.mp4)
:::

``` {.Translate .Exact points="10"}
18 ~S: Suppose you have 'Q → S' as a premise. What is the other premise you need, to apply MT?
```

:::solution
![Solution to 18](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wp_CQS_MT.mp4)
:::

:::

## Conditionals: Why Bother?

Suppose someone asked you what 'if...then...' *means*.
That's a hard question to answer. 
You could do worse than to point them to the validity of Modus Ponens and
Modus Tollens.
Let me explain what I mean by that.

We use 'if' to express a hypothetical. Suppose I say,

:::example
-   If you are made of wood, then you float.
:::

I'm not saying that you *are* made of wood.
I'm just saying that, *if* you are made of wood, 
 *then* you float. 
So when I make this conditionals statement,
 I'm inviting you to consider the possibility that 
 you are made of wood, 
 and asserting that,
 if you were, you would float.

Still, you might feel that this is just idle speculation.
Aren't hypotheticals just a waste of our time,
 a distraction from what is actually the case?

Consider this comment by Don Meredith, 
 from a December 1970 broadcast of Monday Night Football:

>| Howard Cosell: “If Los Angeles wins, it’s a big one, but San Francisco is still very much in it.”
>| Don Meredith: “If 'if's and 'but's were candy and nuts, we’d all have a merry Christmas.”

::: aside
For more on the background to this idiom, see this [thread on
StackExchange](https://english.stackexchange.com/questions/47182/origin-of-the-idiom-if-ifs-and-buts-were-candy-and-nuts){target="_blank"
rel="noopener noreferrer"}.
:::

Put aside the bit about San Francisco.
Cosell asserts a conditional claim:

::: example
| If Los Angeles wins then it's a big win.
:::

Meredith belittles the claim, 
 suggesting that such claims are not worth our time, 
 because they have no real value.
Hypothetical conditionals are a distraction from hard-nosed *reality.
We should attend to what *is* the case,
 not what *would be* the case *if* something else *were* the case.

There is a grain of truth to Meredith's claim.
A conditional, *by itself*, doesn't tell us much.
But the deeper claim is wrong:
 conditionals *do* have teeth,
 and they can teach us important things about reality.
Those teeth take the form of Modus Ponens and Modus Tollens.

Suppose Cosell is right: 'if LA wins, it's a big win for them.' Nothing
follows from that conditional by itself. But suppose LA wins. Then it follows,
by Modus Ponens, that it's a big win---a win with important consquences for
them.

Here is another example.
Suppose you are talking with a friend, and they say:

::: example
-   If he's cheating on you, you should dump him.
:::

And suppose you react like Don Meredith:
 stop bothering me with meaningless hypothetical 'ifs'!
But then you get a text that proves,
 beyond any doubt,
 that he is cheating on you.
Suddenly, your friend's conditional statement has a real impact.
If you agree with them, then you agree that you should dump him:

::: standardform
-   If he is cheating on you, you should dump him.
-   He is cheating on you.
-   You should dump him.
:::

Or, again, suppose the current guidelines say that,

:::example
-   You should get tested only if you have symptoms.
:::

By itself, this rule gives you no guidance at all.
But combine this rule with the fact that you have no symptoms, and the rule
clearly dicates that you should not get tested:

::: standardform
-   You should get testing only if you have symptoms.
-   You don't have symptoms.
-   You should not get tested.
:::

A conditional is a *bridge* between two pieces of information, 
 expressed as its antecedent and consequent.
There are two valid ways to "cross" that bridge: Modus Ponens---the way of
affirming---and Modus Tollens---the way of denying.

Suppose I know that whenever you are happy, 
 you start clapping your hands:

::: example
-   If you are happy, then you clap your hands.
:::

This bit of conditional information can be used in two ways:
 if I know that you are happy,
 I can use it to infer that you are clapping your hands;
 if I know that you are not clapping your hands,
 I can use it to infer that you are not happy.

The first use applies Modus Ponens:

::: {.standardform}
-  If you are happy, you clap your hands.
-  You are happy.
-  You clap your hands.
:::

The second applies Modus Tollens:

::: {.standardform}
-  If you are happy, you clap your hands.
-  You are not clapping your hands.
-  You are not happy.
:::

Note the difference in direction:
 when I use MP, I reason *in the direction* of the arrow;
 when I use MT, I reason *against the direction* of the arrow.

Another example:

::: example
-   If God exists, there is no pointless suffering in the world.
:::

Given this premise, 
 a person of faith might infer, by Modus Ponens,
 that suffering that seems pointless must have some hidden purpose:

::: example
-   If God exists, there is no pointless suffering in the world.
-   God exists.
-   There is no pointless suffering in the world.
:::

Given this same premise, 
 a person who has experienced pointless suffering 
 might infer, by Modus Tollens, that God does not exist.

::: example
-   If God exists, there is no pointless suffering in the world.
-   There is pointless suffering in the world.
-   God does not exist.
:::

Both arguments use the same bridge, the same conditional premise.
But they cross the bridge in opposite directions.
Hence the saying,
 "One person's *Modus Ponens* is another person's *Modus Tollens*."



## Nerd Alert

Want to be an uber logic nerd?
How about listening to a whole song about just how sexy Modus Tollens is?
You even get to choose between a sultry version and an indie lo-fi version:

![Modus Tollens (sultry version)](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/ModusTollens.m4a)

![Modus Tollens (original version)](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/modustollens_orig.m4a)

(Song by [The Monads](https://the21stcenturymonads.net/){target="_blank"
rel="noopener noreferrer"}.
Sultry version peformed by [Carrie Jenkins](https://www.carriejenkins.net/){target="_blank"
rel="noopener noreferrer"}, 
 Canada Research Chair in Philosophy at the University of British Columbia.
Lo-fi version performed by [Kris McDaniel](http://www.krismcdaniel.com/){target="_blank"
rel="noopener noreferrer"}, Professor of Philosophy at the University of Notre Dame.


## Modus Tollens and the Placement of the Negation

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Modus Tollens**

::: {.standardform .liveshapes}
-  [ ]{.P} → [ ]{.Q}
-  ¬[ ]{.Q}
-  ¬[ ]{.P}
:::
:::
:::

Many people, when they first learn Modus Tollens, miss something important.
To apply MT,
 one premise must be a conditional,
 and the other premise must be the *negation of the consequent* of that
 conditional.

This is an instance of MT:

:::standardform
-   P → Q
-   ¬Q
-   ¬P
:::

This is *not* an instance of MT:

:::{.standardform .xed}
-   P → ¬Q
-   Q
-   ¬P
:::

Do you see the difference?
It's about where the negation is.
For an argument to be an instance of MT,
 one premise needs to be the negation of the consequent of the other.
In our second example,
 the consequent is '¬Q'.
'Q' is not the negation of '¬Q'.
The negation of '¬Q' is '¬¬Q'.
So *this* is an instance of MT:

:::{.standardform .xed}
-   P → ¬Q
-   ¬¬Q
-   ¬P
:::

The use of boxes and circles, 
 when presenting the rules,
 is meant to help emphasize this.
If an argument is an instance of MT,
 you can plug its bits and pieces into the boxes and circles,
 and get the exact argument:

:::{.standardform .xed}
-   [P]{.P} → [¬Q]{.Q}
-   ¬[¬Q]{.Q}
-   ¬[P]{.P}
:::

Notice the negations that are *outside* the boxes and circles.
Those negations are part of the form of the rule itself.
They are fixed and non-negotiable.
By contrast, the negations inside the circles are part of the content that
this instance of the rule happens to have.
As far as MT is concerned, they are just along for the ride.

```{.QualitativeProblem .MultipleChoice points=10}
19 <div class="standardform"> <ul> <li>P → ¬Q</li> <li>Q</li> <li>¬P</li> </ul> </div>
| This is an instance of MP
| This is an instance of MT
| *This is not an instance of either MP or MT
20 <div class="standardform"> <ul> <li>¬P → Q</li> <li>¬Q</li> <li>P</li> </ul> </div>
| This is an instance of MP
| This is an instance of MT
| *This is not an instance of either MP or MT
21 <div class="standardform"> <ul> <li>¬P → ¬Q</li> <li>¬Q</li> <li>¬P</li> </ul> </div>
| This is an instance of MP
| This is an instance of MT
| *This is not an instance of either MP or MT
22 <div class="standardform"> <ul> <li>¬P → ¬Q</li> <li>¬P</li> <li>¬Q</li> </ul> </div>
| *This is an instance of MP
| This is an instance of MT
| This is not an instance of either MP or MT
```

:::{.reaction .correct ex=22}
Sometimes, students try to recognize Modus Tollens as "the one that includes
negations". 
But 17 is an instance of MP, even though it includes negations.
To see this, draw the boxes and circles around the parts of the premises:

::: {.standardform .liveshapes}
-   [¬P]{.P} → [¬Q]{.Q}
-   [¬P]{.P}
-   [¬Q]{.Q}
:::

This is an instance of Modus Ponens.
The fact that the antecedent and consequent happen to contain negations is
irrelevant, as far as Modus Ponens is concerned. Those negations are just
along for the ride. Here is an example with this form, in English:

::: {.standardform .liveshapes}
-   If [you are not a witch]{.A} then [you won't float.]{.B}
-   [You are not a witch]{.A}
-   [You won't float]{.B}
:::

See how all the negations are inside the content,
 and don't affect the overall form?
:::

```{.QualitativeProblem .MultipleChoice points=10}
23 <div class="standardform"> <ul> <li>¬P → Q</li> <li>¬Q</li> <li>¬¬P</li> </ul> </div>
| This is an instance of MP
| *This is an instance of MT
| This is not an instance of either MP or MT
```

:::{.reaction .correct ex=23}
If this one tripped you up, again, you need to focus on the *pattern*. Here is
the argument, with boxes and circles, showing how it fits the pattern of Modus
Tollens:

::: {.standardform .liveshapes}
-   [¬P]{.P} → [Q]{.Q}
-   ¬[Q]{.Q}
-   ¬[¬P]{.P}
:::

It happens to be that the antecedent is itself a negation, '¬P'. Modus Tollens
doesn't see that. It just knows that, since the other premise is the negation
of the consequent, the conclusion will be the negation of the antecedent.
Note that the *negation* of '¬P' is '¬¬P'. More generally, the *negation* of a
sentence, '[]{.P}', is that sentence, with an extra negation added in front,
'¬[].{P}'.
:::

:::solution
Finding all of this confusing? Here is another mini-lecture, working through
lots of examples, talking about how to recognize instances of rules.

::: youtube
<https://youtu.be/Ah8wlFjLQ88>
:::
:::
:::

## Using the Rules

We have four rules.
Let's use them!

But first, let me introduce another more compact way of representing arguments.
So far, we have been representing arguments in standard form, like this:

:::standardform
-   P → Q
-   P
-   Q
:::

But it is often convenient to be able to represent an argument all on one
line, listing the premises and conclusion horizontally, rather than
vertically, e.g.,

:::example
-   P → Q, P ∴ Q
:::

Notice that we separate the premises with commas, and mark the conclusion
using '∴'.
It is tempting to misread this, and think that it is a list with two elements:
'P → Q', and 'P ∴ Q'.
But it is a list with three elements:
 'P → Q', 'P', and 'Q'.
The '∴' symbol is not a connective,
 joining 'P' and 'Q' into a new sentence.
It is a conclusion marker.
One way to make that clearer is to enclose the premises in set braces:

:::example
-   $\{$P → Q, P$\}$ ∴ Q
:::

When we write arguments in this horizontal notation,
 we will often replace the three-dots symbol, '∴',
 with a "turnstyle": '⊢'.
This is just another way of marking a conclusion,
 and can also be read as 'therefore'.

:::example
-   P → Q, P ⊢ Q
:::

Again, it is tempting to read this as a list with two items, 'P → Q' and 'P ⊢
Q'. But it is a list with three items, one set off as the conclusion:

:::example
-   $\{$P → Q, P$\}$ ⊢ Q
:::

Time to introduce a new kind of exercise,
 which asks you to apply a rule to some given premises.

Here is a first example:

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" init="now" submission="none"}
Ex P->Q, P :|-: Q
|1.P->Q :PR
|2.P    :PR
|3.Q    :MP 1,2
```

Here, I have applied the rule MP to my two premises, 'P → Q' and 'P'.
To do this, I first wrote down each premise, and marked it as a premise, by
typing ':PR'. Then I wrote down my conclusion, 'Q', and indicated that it
followed, by MP, from lines (1) and (2), by typing ':MP 1,2'.

Try it for yourself:

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
24 Q->R, Q :|-: R
```

:::solution
![Solution to 24](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/rule_CQR_Q.mp4)
:::

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
25 Q :|-: ~~Q 
```

:::solution
![Solution to 25](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/rule_Q_NNQ.mp4)
:::

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
26 P->Q, ~Q :|-: ~P 
```

:::solution
![Solution to 26](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/rule_CPQ_NQ_NP.mp4)
:::

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
27 (P/\Q)->~(R->S), ~~(R->S) :|-: ~(P/\Q)
```

:::solution
![Solution to 27](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/rule_ugly_MT.mp4)
:::

## Direct Derivations

Again, here is a short video lecture, to help orient you:

:::solution
::: youtube
<https://youtu.be/Psbwdq7TTGg>
:::
:::

:::vaside
A [direct derivation (DD)]{.vocab} is a derivation that establishes that a
conclusion follows from the premises by deriving the conclusion directly from
the premises. Other forms of derivation, that are more roundabout, will be
introduced in the next chapter.
:::

In a [direct derivation]{.vocab}, we start from the premises, and then proceed, step by
step, until we reach the conclusion. Each step must be an instance of one of
our inference rules. 

Let's start with an informal example.

::: {.standardform}
-   If Neo takes the red pill, Neo stays in Wonderland.
-   If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes.
-   Neo takes the red pill.
-   Morpheus shows Neo how deep the rabbit hole goes.
:::

Imagine that someone isn't sure whether or not this conclusion follows from
these premises. So, to convince them, we need to construct a proof. We might
begin by stating our goal:

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
:::

Next, we state each of our premises:

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
2.  [If Neo takes the red pill, Neo stays in Wonderland. [PR]{.just}]{.indent}
3.  [If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes. [PR]{.just}]{.indent}
4.  [Neo takes the red pill [PR]{.just}]{.indent}
:::

Note the familiar ':PR', marking each as a premise.

Now I am going to take a step, by MP from (2) and (4):

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
2.  [If Neo takes the red pill, Neo stays in Wonderland. [PR]{.just}]{.indent}
3.  [If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes. [PR]{.just}]{.indent}
4.  [Neo takes the red pill [PR]{.just}]{.indent}
5.  [Neo stays in Wonderland [MP 2,4]{.just}]{.indent}
:::

This step gives me a new piece of information, on line (5), that I can reason
from.
So I take another sttep, again by MP, from lines (3) and (5):

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
2.  [If Neo takes the red pill, Neo stays in Wonderland. [PR]{.just}]{.indent}
3.  [If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes. [PR]{.just}]{.indent}
4.  [Neo takes the red pill [PR]{.just}]{.indent}
5.  [Neo stays in Wonderland [MP 2,4]{.just}]{.indent}
6.  [Morpheus shows Neo how deep the rabbit hole goes [MP 3,5]{.just}]{.indent}
:::

At this point, I have reasoned to the conclusion I set out to show.
The sentence on line (6) is the same as the sentence on line (1), my "show
line".
And each step in my reasoning was an instance of a valid rule.
So I have established that the argument is valid.

So my last step is to announce my success.
A common way to do this is to say 'QED',
 short for 'Quid erat demonstratum': 'it has been demonstrated'.
But we are going to be a bit more specific.
To celebrate our completion, we add one more line,
 indicating that what we have on line (6) is what we needed to get,
 to complete a Direct Derivation (DD):

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
2.  [If Neo takes the red pill, Neo stays in Wonderland. [PR]{.just}]{.indent}
3.  [If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes. [PR]{.just}]{.indent}
4.  [Neo takes the red pill [PR]{.just}]{.indent}
5.  [Neo stays in Wonderland [MP 2,4]{.just}]{.indent}
6.  [Morpheus shows Neo how deep the rabbit hole goes [MP 3,5]{.just}]{.indent}
7.  [:DD 6]{.qed}
:::

To see what this looks like in our formal system,
 we need to translate the argument into SL.

::: stickywrapper
::: soasticky
| P: Neo takes the red pill.
| Q: Neo stays in Wonderland.
| R: Morpheus shows Neo how deep the rabbit hole goes.
:::

::: standardform
-  P → Q
-  Q → R
-  P
-  R
:::

::: proof
1.  [R]{.show}
2.  [P → Q [PR]{.just}]{.indent}
3.  [Q → R [PR]{.just}]{.indent}
4.  [P [PR]{.just}]{.indent}
5.  [Q [MP 2,4]{.just}]{.indent}
6.  [R [MP 3,5]{.just}]{.indent}
7.  [:DD 6]{.qed}
:::
:::

And here is what this looks like,
 when we enter it into Carnap:

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" init="now" submission="none"}
Example P->Q, Q->R, P :|-: R
|1.Show R
|2.  P->Q  :PR
|3.  Q->R  :PR
|4.  P     :PR
|5.  Q     :MP 2,4
|6.  R     :MP 3,5
|7.:DD 6
```

A few things to notice:

-   On each line, except for lines (1) and (7), we have both a sentence and a
    justification. The justification comes after the sentence, and is prefixed
    by a colon, ':'.

That colon is mandatory. It is how Carnap knows how to parse the line.
A common error is to put the justification before the colon (e.g., 'MP: 2,4').
Carnap will choke on that input. Another common error is to put a space
between the colon and the justification (e.g., ': MP 2,4'). Again, Carnap will
choke on that input.

-   Line (1) doesn't have a justification, because it is a show line.

An assertion is a sentence put forth as true, 
 and assertions need to be justified. 
Each of lines (2) through (6) contains an assertion.
But a show line is not an assertion.
It is your bold statement about what you intend to try to show. 
You can *try* to show anything you want:
 no justification is required. 

-   Line (7) doesn't contain an assertion, because it is a QED line.

Line (7) justifies a new assertion.
But the new assertion is justifies is on line (1).
Line (7) is a QED line,
 announcing that you have successfully *shown* what you set out to *show*.

Our system is a simplified version of an older system.
In that older system, there were no QED lines. 
When you completed a derivation, 
 you drew a *box* around all the lines indented below
 the show line, and you crossed out the word 'show':

::: {.proof .km}
1.  [R]{.show}
2.  [P → Q [PR]{.just}]{.indent}
3.  [Q → R [PR]{.just}]{.indent}
4.  [P [PR]{.just}]{.indent}
5.  [Q [MP 2,4]{.just}]{.indent}
6.  [R [MP 3,5]{.just}]{.indent}
:::

Crossing out the word "show" visually emphasizes the transformation of line
(1):
 it goes from being a *goal* to an *accomplishment*,
 an *intention* to a justified *assertion*.
Our system drops the box in favor of a simple vertical line, 
 and drops the convention of crossing out the word "show"
 in favor of a QED line.

## Some Sample Direct Derivations

:::stickywrapper
:::{.aside .sticky .flex }
:::ruledisplay
**DNI and DNE**

:::{.displayed .liveshapes}
-   [ ]{.P} ⊢ ¬¬[ ]{.P} 
-  ¬¬[ ]{.P} ⊢ [ ]{.P}
:::
:::
:::ruledisplay
**MP**

:::{.displayed .liveshapes}
-   [ ]{.P}→[ ]{.Q}, [ ]{.P} ⊢ [ ]{.Q}
:::
:::
:::ruledisplay
**MT**

:::{.displayed .liveshapes}
-  [ ]{.P}→[ ]{.Q}, ¬[ ]{.Q} ⊢ ¬[ ]{.P}
:::
:::
:::

I am providing the rules for your convenience.

Try to complete the following derivation. Note that immediately following the
derivation is a detailed walkthrough. It is fine to complete the derivation by
following the walkthrough!

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
28 P->Q, ~Q :|-: ~P
```

First, enter your show line.
Put your cursor beside the '1.', and type: `Show ~P`, and type "enter" or
"return":

``` {.der}
Show ~P
```

Notice that Carnap automatically numbers the lines for you.
Remember, case matters: make sure you typed in a capital `P`.

**Don't enter a space before the word "Show"** on line 1.
Carnap wants that first line to begin with the letter 'S',
 and will get confused if it begins with a space.

Indent your second line.
Every line *under a show line* needs to be indented.
My habit is to use two spaces to indent.
You can use one space,
 or three spaces,
 or a tab.
Whatever you do,
 be consistent.
If you sometimes use one space, sometimes two, and sometimes a tab,
 Carnap is going to get confused, and choke.

Now type in the first premise, and its justification: `P->Q :PR`, and type
"enter":

``` der
1. Show ~P
2. |  P->Q :PR
3.   
```

Notice that Carnap adds the vertical bar for you.
That is not something you type in.
It is a visual indicator,
 that helps you see that line (2) is part of a proof,
 aimed at showing line (1).

Now type in the second premise, and its justificaiton: `~Q :PR`.
Did you remember to indent?
Are your indentations consistent?
A common mistake is to "outdent" negations,
 to make the lines look better visually. For example:

```{.xed}
2.  P->Q
3. ~Q
```

See how the 'Q' is aligned vertically under the 'P', 
 in a way that is pleasing to the eye?
That may be pleasing to the eye, 
 but it is confusing to Carnap!
Carnap wants consisting indentation,
 not visually pleasing indentation:

```
2.  P->Q
3.  ~Q
```

See how the first character on line (2), 'P',
 is vertically aligned with the first character on line (3), '~'?
That is what Carnap wants.

Our next step is to apply MT:

``` der
1. Show ~P
2. |  P->Q :PR
3. |  ~Q   :PR
4. |  ~P   :MT 2,3
```

Remember, when you apply a rule,
 you need a colon, ':', followed by the rule name, `MT`,
 followed by the line numbers that you are applying the rule to: '2,3'.
Do not separate the colon and the rule name with a space: `: MT`{.xed}.
Do separate the rule name and the line numbers with a space: `:MT 2,3`.
The line numbers can be separated by a comma, as here, or with a space, as you
wish.
Do not write: `:MT 23`{.xed}. Carnap will think you are trying to apply MT to
line 23, which is confusing, because line 23 doesn't exist.

The sentence on line (4) is the sentence on your show line.
So you have successfully completed this derivation.
The last step is to enter your QED line: `:DD 4`.
Note that your QED line is *not indented*.
The colon, ':', needs to be vertically aligned with the 'S' in your show line.

:::solution
![Solution to 28](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/der_CPQ_NQ_NP.mp4)
:::

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10} 
29 P->Q, Q->R, ~R :|-: ~P
```

:::solution
![Solution to 29](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/der_CPQ_CQR_NR_NP.mp4)
:::

So far, we haven't used DN for anything. Here is an example that requires DN:

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10} 
30 ~P->~Q, Q :|-: P
```

And, again, here is a video demonstrating the solution:

:::solution
![Solution to 30](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/der_CNPNQ_Q_P.mp4)
:::

:::

## Wrapping Up

This chapter introduced four new rules of inference: DNE, DNI, MP, and
MT. Here they are, again, all together, in standard form, for easy reference:

:::flex
:::ruledisplay
**DNI**

::: {.standardform .liveshapes}
-   [ ]{.P}
-   ¬¬[ ]{.P} 
:::
:::

:::ruledisplay
**DNE**

::: {.standardform .liveshapes}
-  ¬¬[ ]{.P}
-  [ ]{.P}
:::
:::

:::ruledisplay
**MP**

::: {.standardform .liveshapes}
-  [ ]{.P}→[ ]{.Q}
-  [ ]{.P}
-  [ ]{.Q}
:::
:::

:::ruledisplay
**MT**

::: {.standardform .liveshapes}
-  [ ]{.P}→[ ]{.Q}
-  ¬[ ]{.Q}
-  ¬[ ]{.P}
:::
:::
:::

The chapter also introduced the simplest form of derivation: *Direct* Derivation
(DD). The next chapter will introduce two additional forms of derivation, and
it will introduce the idea of a *sub*derivation—a derivation inside of a
derivation. Your task now is to tackle the [Exercises](05E), and, when you are ready, the
[Mastery Check](05M).



<!-- vim: set ft=carnap :-->
