---
base-css:
-   https://carnap.io/shared/dsanson@gmail.com/sanson-book.css
-   https://cdn.plyr.io/3.6.12/plyr.css
js: 
-   https://cdn.plyr.io/3.6.12/plyr.polyfilled.js
-   https://carnap.io/shared/dsanson@gmail.com/logic-book.js
---

::: {.auto-tally}
:::

::: cover
# Inference Rules and Direct Derivations

![Modus Ponies](http://reggienet.illinoisstate.edu/access/content/user/desanso/public/img/modus_ponies.png){title="Modus
Ponies" alt="A visual pun: two ponies arranged in the form of Modus Ponens."} 

::: epigraph
"The only way to rectify our reasonings is to make them as tangible as those of
the Mathematicians, so that we can find our error at a glance, and when there
are disputes among persons, we can simply say: Let us calculate, without
further ado, to see who is right." 

[[Gottfried Leibniz](https://iep.utm.edu/?p=17335){target="_blank"
rel="noopener noreferrer"}, Letter to Johann Friedrich, 1679]{.source}
<!--_-->
:::
:::


## Introduction

An argument represents your starting point---your premises---and an ending
point---your conclusion. But it doesn't represent the *reasoning* that takes
you from that starting point to that ending point, the path from those premises to that
conclusion.

We call that path a [proof]{.vocab}: a line of reasoning that *establishes*
that a given argument is valid.
And we represent a proof with a [derivation]{.vocab}:
 a series of steps, each an instance of a carefully defined valid 
 [inference rule]{.vocab}, 
 that takes us from the premises to the conclusion.

In this chapter, we carefully define four valid inference rules:
 [Double Negation Elimination (DNE)]{.vocab}, 
 [Double Negation Introduction (DNI)]{.vocab}, 
 [Modus Ponens (MP)]{.vocab},
 and [Modus Tollens (MT)]{.vocab}.

We then put these rules to use, and learn how to construct simple direct
derivations.

In later chapters,
 we will explore more complicated derivations, and
 we will define additional inference rules,
 involving our other connectives.

Your learning objectives for this chapter are:

a.  I can identify instances of the three inference rules, DN, MP, and MT.
b.  I can apply the three inference rules, DN, MP, and MT.
c.  I can complete simple direct derivations

## Proofs and Arguments

Here is a mini-lecture.
It is about 5 minutes long.
It introduces the idea of a proof,
 the idea of a derivation,
 and the idea of an inference rule.
You don't *need* to watch the mini-lecture. 
But you may find that it helps you follow the reading.

:::solution
:::youtube
<https://youtu.be/Ur0SzN406Y8>
:::
:::

A [direct derivation]{.vocab} is the simplest kind of derivation or proof.
It starts from the premises, 
 and proceeds, step by step, 
 from those premises, to the conclusion. 
In a properly constructed derivation,
 each step is valid:
 that is, each step is guaranteed to preserve truth.
Since each step is guaranteed to preserve truth,
 the entire journey is guaranteed to preserve truth.

A properly constructed derivation is like a pipe or wire through which
validity flows:
 *Water* flows through a properly constructed *pipe*. 
 *Electricity* flows through a properly installed *wire*.
 *Validity* flows through a properly constructed *derivation*.
A poorly constructed pipe fails to transmit water from point A to point B,
 either because it has a broken or clogged section,
 or it is missing a section,
 or it doesn't extend from A to B.
A poorly constructed wire fails to transmit electricity from point A to point
B,
 again either because it has a broken or missing section,
 or because it fails to connect A to B.
And a poorly constructed derivation fails to transmit validity,
 either because it has a missing or broken step,
 or because it fails to extend from the premises to the conclusion.

:::illustration
![Water running through a
pipe](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/homer-water.gif){alt="Homer
Simpson has constructed an elaborate pipe that directs water leaking through
the ceiling out the mail slot in the front door."}
:::

How do we ensure that each step in a derivation is valid?
We require that each step be an instance of one of our [inference rules]{.vocab},
 and we make sure that each inference rule is valid.

So, before we look more closely at derivations, 
 let's introduce our first four inference rules:
 Double Negation Elimination (DNE), 
 Double Negation Introduction (DNI), 
 Modus Ponens (MP), 
 and Modus Tollens (MT).

## Double Negation Introduction and Double Negation Elimination

Here is another mini-lecture, introducing our first two rules,
 Double Negation Introduction
 and Double Negation Elimination.

:::solution
::: youtube
<https://youtu.be/k5O1qop2FE4>
:::
:::

Consider these two arguments:

:::standardform
-   She loves me.
-   It is not the case that she doesn't love me.
:::

:::standardform
-   It is not the case that she doesn't love me.
-   She loves me.
:::

:::aside
:::illustration
![She loves me, she loves me
not...](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/img/she_loves_me.gif){alt="An animation showing Yogi Bear pulling petals off of a daisy."}
:::
:::

You are probably familiar with [the old game](https://en.wikipedia.org/wiki/He_loves_me..._he_loves_me_not){target="_blank"
rel="noopener noreferrer"}: <!--_-->
 you pluck a petal off a flower,
 and, with each petal,
 you alternate between saying, 'she loves me',
 and 'she loves me not'.
The truth is revealed when you pluck the last petal.

If 'she loves me' is in fact true, then
 your first sentence, when you pluck the first petal, is true,
 and your second sentence, 'she loves me not', is false,
 and your third sentence, 'she loves me', is true,
 and so on.
If 'she loves me' is in fact false, then
 your first sentence, when you pluck the first petal, is false,
 and your second sentence, 'she loves me not', is true,
 and your third sentence, 'she loves me', is false,
 and so on.

We can represent this with a table:

::: itt
   She loves me   She loves me not   She loves me   She loves me not   ...
  -------------- ------------------ -------------- ------------------ -----
        T                F                T                F           ...
        F                T                F                T           ...
:::

The first row represents how the game plays out when 'She loves me' is actually true.
The second row, when 'She loves me' is actually false.
Of course, 
 the pretense of the game is that you don't know which row you are on
 until you pluck that last petal,
 and discover the truth.

As a logic professor, I prefer a slightly tweaked version of the game.
Instead of alternating between 'she loves me' and its negation, 
 I like to add an *additional* negation each time I pluck a petal.
That way, the game is more exciting and less repetitive.

And, as a logic professor, I prefer to avoid the stilted and stylized English of the traditional game:

:::example
-   She loves me.
-   She does not love me.
-   It is not the case that she does not love me.
-   It is not the case that it is not the case that she does not love me.
-   and so on...
:::

And, as a logic professor, 
 I prefer to play the game in SL rather than English.
So I use the sentence letter 'P' to stand for the English sentence, 'She loves me', 
 and as I pluck each petal, I say:

:::example
-   P (pronounced "pee")
-   ¬P ("not pee")
-   ¬¬P ("not not pee")
-   ¬¬¬P ("not not not pee")
-   ¬¬¬¬P ("not not not not pee")
-   and so on...
:::

Everyone tells me I'm fun at parties.

My game is different from the traditional game.
In the traditional game, 
 you alternate between the same two sentences.
In my game, 
 with every petal, 
 I utter a *new* and *longer* sentence each time.
But at the level of truth values, 
 the two games are the same:
 just as your sentences alternate between true and false,
 my sentences also alternate between true and false.
For example, if 'P' is in fact true, then
 my second sentence, '¬P', is false,
 my third sentence, '¬¬P', is true,
 my fourth sentence, '¬¬¬P', is false,
 and so on.
And if 'P' is in fact false, then
 my second sentence, '¬P', is true,
 my third sentence, '¬¬P', is false,
 my fourth sentence, '¬¬¬P', is true,
 and so on.

Again, we can represent this with a table:

::: itt
   P   ¬P   ¬¬P   ¬¬¬P   ¬¬¬¬P   ¬¬¬¬¬P   ...
  --- ---- ----- ------ ------- -------- -----
   T   F     T     F       T       F      ...
   F   T     F     T       F       T      ...
:::

The first row represents how the game plays out when 'P' is true.
The second row, how the game plays out when 'P' is false.

Consider just the first three columns of my game:

::: itt
   P   ¬P   ¬¬P
  --- ---- -----
   T   F     T
   F   T     F
:::

The second column represents the negation of 'P'.
The third column represents the negation of '¬P',
 which is also the *double-negation* of 'P'.
When you negate a sentence,
 the truth value of the negation is
 always the opposite of the truth value of the sentence negated.
So when you *double-negate* a sentence,
 the truth value of the double negated sentence is
 always the same as the truth value of the sentence double-negated.

This gives us our first two rules of inference:

Double Negation Introduction (DNI)
:   Given any sentence, []{.P}, as your premise, 
    you can infer its double negation, ¬¬[]{.P},
    as your conclusion.

Double Negation Elimination (DNE)
:   Given the double negation, ¬¬[]{.P}, 
    of any sentence, []{.P}, as your premise, 
    you can infer that sentence, []{.P},
    as your conclusion.

Here is an instance of DNE, in English:

:::standardform
-   I don't not care.
-   I care.
:::

The premise is the double-negation of the conclusion, 'I care'.
So we know that the premise and the conclusion will always have the same truth
value.
So this form of argument is valid.

If we use 'Q' for 'I care', we can translate the argument into SL:

:::standardform
-   ¬¬Q
-   Q
:::

Here is another instance of DNE in English:

:::standardform
-   It is not the case that you aren't wrong.
-   You are wrong.
:::

If we use 'W' for 'You are wrong', we can translate this argument into SL:

:::standardform
-   ¬¬W
-   W
:::

Again, the premise is the double-negation of the conclusion, 
 'You are wrong'.
So, again, we know that 
 the premise and conclusion 
 must always agree in truth value.
So we know that the argument must always preserve truth, and so is valid.

Here is the abstract form of DNE, in SL:

:::{.standardform .liveshapes}
-   ¬¬[]{.P}
-   []{.P} 
:::

Plug in any sentence from SL into both boxex,
 and you get an instance of DNE,
 and so a valid inference.

Time to introduce a new type of exercise.
Each of the following questions gives you a premise, 
 and asks you what follows from that rule by DNE.
Type in the correct sentence in SL to answer the question.

(As with translation exercises,
 you must type "enter" or "return" to check your answer,
 before then clicking "Submit" to submit your answer.)


``` {.Translate .Exact points="10"}
1 R: Suppose you have ¬¬R as a premise. What follows, by DNE?
```

:::solution
![solution to question 1](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/not_not_R.mp4)
:::


``` {.Translate .Exact points="10"}
2 P/\Q: Suppose you have ¬¬(P ∧ Q) as a premise. What follows, by DNE?
```

:::solution
![solution to 2](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNE_NNCPQ.mp4)
:::

No doubt you've been told
 at some point in your education 
 to avoid double negatives.
That is a good rule of thumb for speaking and writing:
 better to say, 'Everyone is coming to my party',
 than 'Nobody is not coming to my party',
 even though the two sentences mean the same thing.

But this is terrible advice for doing logic.
We want to *explore* the *logic* of negation,
 and that includes the logic of *double negation*.
We are interested in understanding *why* 'Everyone is coming to my party' and
'Nobody is not coming to my party' mean the same thing.
So, in this class, it is not wrong to not avoid double negations.

Here is an instance of Double Negation Introduction (DNI):

:::standardform
-   We are coping with the pandemic the best we can.
-   We aren't not coping with the pandemic the best we can.
:::

If we use 'P' to stand for 'We are coping with the pandemic the best we can',
 we can translate this into SL:

:::standardform
-   P
-   ¬¬P
:::

Instances of DNI are valid for the same reason that instances of DNE are
valid:
 the premise and conclusion must have the same truth value,
 so the argument is guaranteed to preserve truth.

Here is the general form of the rule:

:::{.standardform .liveshapes}
-   []{.P} 
-   ¬¬[]{.P}
:::

DNI is just like DNE, but the premise and conclusion are reversed.
DNE allows us to *eliminate* a double negation: hence its name!
DNI allows us to *introduce* a double negation, hence its name.

``` {.Translate .Exact points="10"}
3 ~~(P->Q): Suppose you have P → Q as a premise. What follows, by DNI?
```
:::solution
![Solution to 3](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNI_CPQ.mp4)
:::

``` {.Translate .Exact points="10"}
4 ~~(P /\ Q -> Q \/ R): Suppose you have P∧Q → Q∨R as a premise. What follows, by DNI?
```
:::solution
![Solution to 4](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNI_CKPQAQR.mp4)
:::

## Distinct but Logically Equivalent

This section is an aside. 
But it is an important aside.
It addresses a common stumbling block when thinking about double
negations.

A sentence and its double negation are [logically equivalent]{.vocab}:

Logical Equivalence
:   [Two sentences, []{.P} and []{.Q}, are [logically equivalent]{.vocab}
    iff necessarily, they have the same truth value.]{.def}

:::.aside
Remember, 'iff' is not a typo. It is short for 'if and only if', and expresses
the biconditional.
:::

But a sentence and it double negation are *not the same sentence*.
The sentence, 'I don't not care' 
 *means the same thing as* 
 the sentence 'I care'. 
But it is *not the same sentence* as 'I care'.
It is four words long and contains two negations;
 'I care' is two words long and contains no negations.

It is easy to confuse these two things.
If you do, you will fall into the trap of imagining that,
 since 'P' and '¬¬P' are *logically equivalent*,
 they are basically *the same sentence*,
 and so can be used interchangeably.

Our inference rules are based on the *logical forms* of *sentences*.
Whether or not an argument counts as an instance of a rule
 depends on whether or not the *sentences* used to express the premises and
 conclusion fit the *pattern*.
So this is an instance of DNI:

:::standardform
-   P
-   ¬¬P
:::

But this is *not* an instance of DNI:

:::standardform
-   P
-   P
:::

See how in the two cases, the conclusions are *different sentences* that are
*logically equivalent*? In order to recognize that the first, but not the
second, is an instance of the rule, you need to pay attention tot he
*sentences*, not just *what they mean*.
So you cannot simply *replace* an occurrence of '¬¬P' with 'P',
 and act as though it is the same sentence.

In Algebra,
 you learned that two *negatives* cancel each other out.
So you learned that $--x = x$.
And you learned to *simplify* algebraic expressions
 by *cancelling out* double negatives.
So, given $--(x + y) = 15$,
 you simplify it to $x + y = 15$.
You have done this so many times that it is probably
 an automatic habit:
 perhaps you don't even notice when you do it.

Our negation symbol, '¬', 
 looks a lot like the sign used to indicate a negative number.
So it is easy to extend your habits from Algebra to sentences in SL.
So you might find yourself replacing '¬¬P' with 'P', or 'P ∧ ¬¬Q' with 'P ∧
Q', and you ight not even notice when you do it.

But this is a mistake:
 if your premise is '¬¬P', you have to write it as '¬¬P';
 if your premise is 'P ∧ ¬¬Q', you have to write it as 'P ∧ ¬¬Q'.
You cannot "cancel out" the negations "in your head", like you may have done
in Algebra.

Again, we want to focus our *attention on*
 the *logic* of negations, including double negations.
You can't do this if you don't even *see* double negations,
 because your brain rushes to "cancel them out",
 before they even get written down.
So you must unlearn that habit,
 or, at least, learn not to apply it here.

## Rules as Patterns

DNI and DNE are patterns.
Given any sentence, you can use DNI to infer its double negation.
For example:

:::{.standardform .liveshapes}
-  [¬P]{.P}
-  ¬¬[¬P]{.P}
:::

Here, the conclusion is the triple negation of 'P'.
But it is also the double negation of '¬P',
 and that's why this counts as a legitimate instance of DNI.

Remember my version of "she loves me/she loves me not",
 and how I just kept on adding negations.
DNI and DNE allow you to add or remove negations,
 but always two at a time.

Note also that this is *not* and instance of DNI:

:::{.standardform .liveshapes}
-  P ∨ [Q]{.P}
-  ¬¬[Q]{.P}
:::

The rule says that, when applying DNI,
 your conclusion must be the double negation of your premise.
So when you apply DNI to this premise, it looks like this:

:::{.standardform .liveshapes}
-  [P ∨ Q]{.P}
-  ¬¬[(P ∨ Q)]{.P}
:::

There is no unstated extra provision,
 that allows you to apply DNI or DNE
 just to one *part* of your premise.

```{.QualitativeProblem .MultipleChoice points=10}
5 <div class="standardform"> <ul> <li>Q</li> <li>¬Q</li> </ul> </div>
| This is an instance of DNI
| This is an instance of DNE
| *This is not an instance of DNI or DNE
6 <div class="standardform"> <ul> <li>¬¬¬¬Q</li> <li>¬¬Q</li> </ul> </div>
| This is an instance of DNI
| *This is an instance of DNE
| This is not an instance of DNI or DNE
7 <div class="standardform"> <ul> <li>Q</li> <li>¬¬¬¬Q</li> </ul> </div>
| This is an instance of DNI
| This is an instance of DNE
| *This is not an instance of DNI or DNE
```

:::{.reaction .correct ex=7}
:::standardform
-   Q
-   ¬¬¬¬Q
:::

This is a valid argument, but it is not an instance of DNI.
The only possible instance of DNI from 'Q' as a premise is:

:::standardform
-   Q
-   ¬¬Q
:::

And the only possible instance of DNI that has '¬¬¬¬Q' as conclusion is:

:::standardform
-   ¬¬Q
-   ¬¬¬¬Q
:::

So, if we want to derive '¬¬¬¬Q' from 'Q', we will need to take *two steps*.
First, we can infer '¬¬Q' from 'Q' by DNI, then we can infer '¬¬¬¬Q' from
that, again by DNI.
:::

```{.QualitativeProblem .MultipleChoice points=10}
8 <div class="standardform"> <ul> <li>(P∧Q)</li> <li>¬¬(P∧Q)</li> </ul> </div>
| *This is an instance of DNI
| This is an instance of DNE
| This is not an instance of DNI or DNE
9 <div class="standardform"> <ul> <li>¬¬(P ∧ Q ↔ Q ∨ R)</li> <li>(P ∧ Q ↔ Q ∨ R)</li> </ul> </div>
| This is an instance of DNI
| *This is an instance of DNE
| This is not an instance of DNI or DNE
10 <div class="standardform"> <ul> <li>P→Q</li> <li>P→¬¬Q</li> </ul> </div>
| This is an instance of DNI
| This is an instance of DNE
| *This is not an instance of DNI or DNE
```

:::{.reaction .correct ex=10}
This argument is not an instance of DNI:

:::standardform
-   P → Q
-   P → ¬¬Q
:::

As explained above, when you apply DNI to a premise,
 you must double negate the *entire premise*,
 not just a part of the premise.

This argument is valid,
 but we do not yet have the tools needed to explain why it is valid,
 and we won't until the next unit.
:::


``` {.Translate .Exact points="10"}
11 ~~(P->(Q\/R)): Suppose you have P → (Q ∨ R) as a premise. What follows, by DNI?
```

:::solution
![Solution to 11](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNI_CPAQR.mp4)
:::

``` {.Translate .Exact points="10"}
12 ~~P->(~~Q\/~~R): Suppose you have ¬¬(¬¬P → (¬¬Q ∨ ¬¬R)) as a premise. What follows, by DNE?
```

:::solution
![Solution to 12](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_DNE_NNbigmess.mp4)
:::

## Modus Ponens

Again, here is a video mini-lecture, 
 which you may find helps you follow the reading.

:::solution
::: youtube
<https://youtu.be/qJbHNMhxOUc>
:::
:::

So far, we have only considered rules involving negation.
In this section, we consider two rules that involve conditionals.

The first is called [Modus Ponens (MP)]{.vocab}.
Here is an instance of Modus Ponens in English:

:::standardform
-   If you are feeling sick, then you should stay home.
-   You are feeling sick.
-   You should stay home.
:::

Convince yourself that this argument is valid.

Let's break it down.

:::standardform
-   If [you are feeling sick]{.P .mpantecedent}, then [you should stay
    home]{.Q .mpconsequent}.
-   [You are feeling sick]{.P .mppremise}.
-   [You should stay home]{.Q .mpconclusion}.
:::

The first premise is a conditional. 
A conditional makes a hypothetical claim:
 *if* such and such hypothetical condition 
 expressed by the antecedent obtains, 
 *then* this other condition,
 expressed by the consequent
 also obtains.
Specifically,
 *if* you are feeling sick,
 *then* you should stay home.
the other premise tells us that the hypothetical condition does in fact
obtain:
 you are feeling sick.
So it follows that the condition expressed by the consequent also obtains:
 you should stay home.

Here is another instance of MP in English:

:::standardform
-   If [our winter is unusually cold]{.P .mpantecedent}, then [some of the less hardy plants die]{.Q .mpconsequent}.
-   [Our winter is unusually cold]{.P .mppremise}.
-   [Some of the less hardly plants die]{.Q .mpconclusion}.
:::

Again, this argument is valid, and for the same reason.
The conditional premise relates the two conditions,
 and says that
 *if* the condition expressed by the antecedent holds,
 *then* the condition expressed by the consequent holds.
The second premises says that the hypothetical condition---
 the condition expressed by the antecedent---
 does actually obtain.
From these two premises together,
 it follows that the condition expressed by the consequent obtains as well.

(Quick refresher:

| the [antecedent]{.vocab} of a conditional is the part that comes *before*
  the arrow;
| the [consequent]{.vocab} is the part that comes *after* the arrow.

The prefix 'ante' means *before*. When you play poker, the ante is the stake
put up *before* the deal. Since I'm a hipster, was into it before it was cool:
that is, my interest *ante*dates its being cool. An *ante*chamber or
*ante*room is a waiting room that you enter *before* you enter the main room.
The consequent is what *comes after*, in the sense of *following*, not
in time, but logically.)

Modus Ponens has an evil twin,
 an argument form that looks similar,
 but is *not* valid.
It is called [Affirming the Consequent]{.vocab}.
Here is an example:

:::{.standardform .exed}
-   If [you are feeling sick]{.P .mpconsequent}, then [you should stay
    home]{.Q .mpantecedent}.
-   [You should stay home]{.Q .mppremise}.
-   [You are feeling sick]{.P .mpconclusion}.
:::

Do you see how this argument makes the mistake
 of reading the conditional premise backwards?
The premise does not say that
 if you should stay home
 then you are feeling sick.
It says that
 if you are feeling sick
 then you should stay home.
We cannot infer from this that,
 since you should stay home,
 it must be that you are sick.
There are plenty of other possible reasons why it might be
 true that you should stay home:
 maybe today is a holiday, for example.


Here is another example of Affirming the Consequent:

:::{.standardform .exed}
-   If Fido is a cat, then Fido is a mammal.
-   Fido is a mammal.
-   Fido is a cat.
:::

Again, the argument is not valid.
The conditional premise says that
 if Fido is a cat,
 then Fido is a mammal.
It doesn't say that
 if Fido is a mammal,
 then Fido is a cat.
Suppose Fido is a dog:
 then both premises can be true,
 but the conclusion false.

::: stickywrapper
::: {.aside .sticky .flex}
:::ruledisplay
**Modus Ponens (MP)**

:::{.standardform .liveshapes}
-  [ ]{.P .mpantecedent} → [ ]{.Q .mpconsequent}
-  [ ]{.P .mppremise}
-  [ ]{.Q .mpconclusion}
:::
:::
:::ruledisplay
**Affirming the Consequent**

:::{.standardform .liveshapes .xed}
-   []{.P .mpconsequent} → []{.Q .mpantecedent}
-   []{.Q .mppremise}
-   []{.P .mpconclusion}
:::
:::
:::

We could call Modus Ponens "Affirming the Antecedent".
That is basically what 'Modus Ponens' means in Latin:
 'modus' means 'way';
 'ponens' means 'putting' or 'setting' or 'positing',
 or, in a logical context, 'affirming'.
So 'Modus Ponens' means, roughly,
 'the way of putting/positing/affirming'.
When you apply Modus Ponens, you have two premises:
 one is a conditional;
 the other affirms its antecedent.

By contrast, when you mistakenly apply Affirming the Consequent instead,
 you have two premises:
 one a conditional,
 and the other affirming the consequent.


:::illustration
![Hermione on the proper way to pronounce 'Modus
Ponens'](http://reggienet.illinoisstate.edu/access/content/user/desanso/public/img/leviosa.gif)
:::

Actually, the original full Latin name of the rule is 'Modus Ponendo Ponens':
 "the way of positing/affirming by positing/affirming".
When you apply Modus Ponens,
 your premise affirms the antecedent,
 and this entitles you to affirm the consequent.
This is the only *valid* rule that allows you to affirm by affirming,
 since Affirming the Consequent is not valid.

``` {.Translate .Exact points="10"}
13 Q: Suppose you have P → Q as one premise, and P as your other premise. What follows, by MP?
```

:::solution
![Solution to 13](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_MP_CPQ_P.mp4)
:::

``` {.Translate .Exact points="10"}
14 Q: Suppose you have Q → P as a premise. What other premise do you need, to apply MP?
```

:::solution
![Solution to 14](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/mp_MP_CQP.mp4)
:::

``` {.Translate .Exact points="10"}
15 R: Suppose you have P∧Q → R as one premise, and P∧Q as your other premise. What follows, by MP?
```

:::solution
![Solution to 15](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_MP_CKPQR.mp4)
:::

``` {.Translate .Exact points="10"}
16 R->Q: Suppose you have (R → Q) → R as a premise. What other premise do you need, to apply MP?
```

:::solution
![Solution to 16](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wp_CRCQR_MP.mp4)
:::

:::

## Modus Tollens

We have one more rule to introduce: [Modus Tollens (MT)]{.vocab}.
'Tollens', in Latin, means 'taking' or 'denying'.
And actually, the original full Latin name is 'Modus Tollendo Tollens':
 the way of taking/denying by taking/denying.

Here is an example:

:::standardform
-   If [the laws are just]{.mtantecedent}, then [it is wrong to break them]{.mtconsequent}.
-   [It is]{.mtpremise} not [wrong to break the laws]{.mtpremise}.
-   [The laws are]{.mtconclusion} not [just]{.mtconclusion}.
:::

Do you see that this is valid?
One premise is a conditional.
It does not say that the laws *are* just.
But it says that on the hypothesis that they are, 
 it is wrong to break them.
The other premise says that it is *not* wrong to break the laws:
 it denies or rejects the consequent.
But that means that the hypothetical condition,
 expressed by the antecedent,
 must not obtain:
 if it did, then the consquent would too.
So the laws must not be just.

Here is another (slightly dated) example:

:::standardform
-   Kyrie can play in NYC only if he is vaccinated.
-   Kyrie is not vaccinated.
-   Kyrie cannot play in NYC.
:::

Remember how 'only if' works: it marks 'he is vaccinated' as the *consequent*.
So we can restate this argument as:

:::standardform
-   If Kyrie can play in NYC then he is vaccinated.
-   Kyrie is not vaccinated.
-   Kyrie cannot play in NYC.
:::

Again, one premise is a conditional.
Again, the other premise is the negation of the consequent.
Again, the conclusion is the negation of the antecedent.

Here is the pattern:

:::standardform
-   []{.P .mtantecedent} → []{.Q .mtconsequent}
-   ¬[]{.Q .mtpremise}
-   ¬[]{.P .mtconclusion}
:::

We saw that Modus Ponens is the only valid form of argument that involves
*affirming* one part of a conditional, and so *affirming* the other part. To
do this validly, you must always reason from the antecedent to the consequent,
in the direction of the arrow. If you try to reason backwards, from consequent
to antecedent, your inference is invalid. 

In the same way, Modus Tollens is the only valid form of argument that
involves *denying* one part of a conditional, and so *denying* the other part.
To do this validly, you must always reason from the negation of the consequent
to the negation of the antecedent, against the direction of the arrow. If you
try to reason forwards, from the negation of antecedent to the negation of the
consequent, your inference is invalid.

We call that invalid form of inference---Modus Tollens's evil twin---"Denying the Antecedent".
Here is an example:

:::{.standardform .xed}
-   If [Fido is a dog]{.mtconsequent} then [Fido is a mammal]{.mtantecedent}.
-   [Fido is]{.mtpremise} not [a dog]{.mtpremise}.
-   [Fido is]{.mtconclusion} not [a mammal]{.mtconclusion}.
:::

Do you see that this is not valid? 
Suppose Fido is a cat.
Then both premises are true, but the conclusion is false.

::: stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Modus Tollens (MT)**

:::{.standardform .liveshapes}
-   []{.P} → []{.Q}
-   ¬[]{.Q}
-   ¬[]{.P}
:::
:::

:::ruledisplay
**Denying the Antecedent**

::: {.standardform .liveshapes .xed}
-   []{.P} → []{.Q}
-   ¬[]{.P}
-   ¬[]{.Q}
:::
:::
:::

When reasoning with conditionals, you must pay close attention to the
direction of the conditional---to which part is the antecedent and which the
consequent. Affirming the Consequent and Denying the Antecedent are mistakes
people make when they fail to pay proper attention to this.
The premise, 'if Fido is a dog, then Fido is a mammal' is *not the same as*
the premise, 'if Fido is a mammal, then Fido is a dog', and your reasoning
needs to respect this.

``` {.Translate .Exact points="10"}
17 ~R: Suppose you have 'R → P' and '¬P' as your premises. What follows by MT?
```

:::solution
![Solution to 17](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wf_CRP_NP_MT.mp4)
:::

``` {.Translate .Exact points="10"}
18 ~S: Suppose you have 'Q → S' as a premise. What is the other premise you need, to apply MT?
```

:::solution
![Solution to 18](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/wp_CQS_MT.mp4)
:::

:::

## Conditionals: Why Bother?

Conditionals express hypotheticals.
Suppose I say,

:::example
-   If you are made of wood, then you will float.
:::

I'm not saying that you *are* made of wood.
I'm just saying that, *if* you are made of wood, 
 *then* you will float. 
So when I make this conditional or hypothetical statement,
 I'm inviting you to consider the possibility that 
 you are made of wood, 
 and asserting that,
 if that possibility actually obtains,
 then you will float.

But what's the point of hypotheticals? Why waste our time thinking about
hypothetical possibilities? Shouldn't we just focus on reality?

> | Howard Cosell: "If Los Angeles wins, it's a big one, but San Francisco is
>   still very much in it."
> | Don Meredith: "If 'if's and 'but's were candy and nuts, we'd all have a
>   merry Christmas." (Monday Night Football, December 1970)

::: aside
For more on the background to this idiom, see this [thread on
StackExchange](https://english.stackexchange.com/questions/47182/origin-of-the-idiom-if-ifs-and-buts-were-candy-and-nuts){target="_blank"
rel="noopener noreferrer"}.<!--_-->
:::

Let's put aside the bit about 'but's and San Francisco, and just focus on the
part about Los Angeles.
Cosell asserts a conditional, or hypothetical, claim:

::: example
| If Los Angeles wins then it's a big win.
:::

Meredith belittles the claim, 
 and suggests that hypotheticals are not real, and so a distraction.
We should attend to what *is* the case,
 not what *will be* the case *if* something else *is* the case.

There is a grain of truth to what Meredith says. Taken *by itself*, a
conditional doesn't tell us much. But Meredith is wrong: conditionals *do*
have teeth, and they do tell us important things about reality. It's just
that, to engage those teeth, we need to pair a conditional with its
antecedent, or the negation of its consequent. In other words, the teeth of a
conditional can only get there grip on reality *via* Modus Ponens and Modus
Tollens.

Suppose Cosell is right: 'if LA wins, it's a big win for them.' Nothing
follows from that conditional by itself. But now suppose LA wins. It follows
(assuming Cosell was right), that LA has a big win.

Suppose you are talking with a friend, and they say:

::: example
-   If he's cheating on you, you should dump him.
:::

Your inner Don Meredith belittles what they've said.
 *Stop bothering me with meaningless hypothetical 'ifs'!*,
 you say to yourself.
But your partner accidentally sends you a text meant the other man he's been
seeing. So now you know that he *is* cheating on you. Do you dump him or not?
That depends. The following argument is valid:

::: standardform
-   If he is cheating on you, you should dump him.
-   He is cheating on you.
-   You should dump him.
:::

So, if you hesitate to dump him, it must be that you are unsure of the *truth*
of one of the premises. But you know that the second premise is true. So you
must be doubting the truth of the first premise. So what you should with your
relationship hinges on the truth or falsity of that conditional.

One more example. Suppose some new disease is tearing through our community,
and the current CDC guidelines say,

:::example
-   You should get tested only if you have symptoms.
:::

By itself, this rule gives you no guidance at all.
But combine this rule with the fact that you have no symptoms, and the rule
tells you not to get tested:

::: standardform
-   You should get testing only if you have symptoms.
-   You don't have symptoms.
-   You should not get tested.
:::

A conditional is a *bridge* between two pieces of information.
There are two valid ways to "cross" that bridge: Modus Ponens---the way of
affirming---and Modus Tollens---the way of denying.

Suppose I know that whenever you are happy, 
 you start clapping your hands:

::: example
-   If you are happy, then you clap your hands.
:::

This bit of conditional information can be used in two ways:
 if I know that you are happy,
 I can use it to infer that you are clapping your hands;
 if I know that you are not clapping your hands,
 I can use it to infer that you are not happy.
That is, I can either apply Modus Ponens:

::: {.standardform}
-  If you are happy, you clap your hands.
-  You are happy.
-  You clap your hands.
:::

Or I can apply Modus Tollens:

::: {.standardform}
-  If you are happy, you clap your hands.
-  You are not clapping your hands.
-  You are not happy.
:::

Again, pay attention both to the difference in affirmation versus negation,
and the difference in *direction*:
 when I use MP, I reason *in the direction* of the arrow;
 when I use MT, I reason *against the direction* of the arrow.

One last example:

::: example
-   If God exists, there is no pointless suffering in the world.
:::

Given this premise, 
 a person of faith might infer, by Modus Ponens,
 that suffering that seems pointless must have some hidden purpose:

::: example
-   If God exists, there is no pointless suffering in the world.
-   God exists.
-   There is no pointless suffering in the world.
:::

Alternatively, someone might instead infer, by Modus Tollens, that God does
not exist:

::: example
-   If God exists, there is no pointless suffering in the world.
-   There is pointless suffering in the world.
-   God does not exist.
:::

Both arguments use the same bridge, the same conditional premise.
But they cross the bridge in opposite directions.
Hence the saying,

> "One person's *Modus Ponens* is another person's *Modus Tollens*."

## Nerd Alert

Want to be an uber logic nerd? Here are two versions 'Modus Tollens', a song
about "the sexiest inference rule around":

![Modus Tollens (sultry)](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/ModusTollens.m4a)

![Modus Tollens (indie lo-fi)](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/modustollens_orig.m4a)

(Song by [The Monads](https://the21stcenturymonads.net/){target="_blank"
rel="noopener noreferrer"}. <!--_-->
Sultry version performed by [Carrie Jenkins](https://www.carriejenkins.net/){target="_blank"
rel="noopener noreferrer"}, <!--_-->
 Canada Research Chair in Philosophy at the University of British Columbia.
Lo-fi version performed by [Kris McDaniel](http://www.krismcdaniel.com/){target="_blank"
rel="noopener noreferrer"}, Professor of Philosophy at the University of Notre
Dame.) <!--_-->

## Modus Tollens and the Placement of the Negation

:::stickywrapper
:::{.aside .sticky .flex}
:::ruledisplay
**Modus Tollens**

::: {.standardform .liveshapes}
-  [ ]{.P} → [ ]{.Q}
-  ¬[ ]{.Q}
-  ¬[ ]{.P}
:::
:::
:::

There is something about MT that is easy to miss.
To apply MT,
 one premise must be a conditional,
 and the other premise must be the *negation of the consequent* of that
 conditional.

So this is an instance of MT:

:::standardform
-   P → Q
-   ¬Q
-   ¬P
:::

But this is *not* an instance of MT:

:::{.standardform .xed}
-   P → ¬Q
-   Q
-   ¬P
:::

Do you see the difference?
It's about where the negation is.

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
19 Describe the difference between the two examples, and explain why the first is an instance of MT, but the second is not.
```

:::{.reaction .correct ex=19}

If you are having trouble seeing this, try obtaining the second example by
typing sentences into the boxes and circles in the pattern:

::: {.standardform .liveshapes}
-  [ ]{.P} → [ ]{.Q}
-  ¬[ ]{.Q}
-  ¬[ ]{.P}
:::

If you put a 'P' into the boxes and a 'Q' into the circle, you get the first
example. Try it yourself. 

But it is impossible to fill in the circles in a way that will make the second
premise 'Q'. That negation in front of the circle on the second premise is a
fixed part of the pattern, and cannot be edited.
:::

Again, this is not an instance of MT:

:::{.standardform .xed}
-   P → ¬Q
-   Q
-   ¬P
:::

But this is:

:::{.standardform} 
-   P → ¬Q
-   ¬¬Q
-   ¬P
:::

Do you see the difference? Again, it is about where the negations are.

```{.QualitativeProblem .ShortAnswer give-credit="onSubmission" points=10}
20 Describe the difference between the two examples, and explain why the first is not an instance of MT, but the second is.
```

:::{.reaction .correct ex=20}
Again, if you are having trouble seeing the difference and explaining it, try
typing sentences into the boxes and circles of the pattern, and think about
why you cannot generate the first example, but you can generate the second:

::: {.standardform .liveshapes}
-  [ ]{.P} → [ ]{.Q}
-  ¬[ ]{.Q}
-  ¬[ ]{.P}
:::

As we saw above, there is no way to make the second premise be just plain 'Q',
because that negation in front of the circle is a fixed part of the pattern.
But you can make the second premise be '¬¬Q', by typing '¬Q' into the circle.
:::

```{.QualitativeProblem .MultipleChoice points=10}
21 <div class="standardform"> <ul> <li>P → ¬Q</li> <li>Q</li> <li>¬P</li> </ul> </div>
| This is an instance of MP
| This is an instance of MT
| *This is not an instance of either MP or MT
22 <div class="standardform"> <ul> <li>¬P → Q</li> <li>¬Q</li> <li>P</li> </ul> </div>
| This is an instance of MP
| This is an instance of MT
| *This is not an instance of either MP or MT
23 <div class="standardform"> <ul> <li>¬P → ¬Q</li> <li>¬Q</li> <li>¬P</li> </ul> </div>
| This is an instance of MP
| This is an instance of MT
| *This is not an instance of either MP or MT
24 <div class="standardform"> <ul> <li>¬P → ¬Q</li> <li>¬P</li> <li>¬Q</li> </ul> </div>
| *This is an instance of MP
| This is an instance of MT
| This is not an instance of either MP or MT
```

:::{.reaction .correct ex=24}
Sometimes, students try to distinguish MP and MT by thinking of MT as "the one
that involves negations". 
But 24 is an instance of MP, even though it involves negations:

::: {.standardform .liveshapes}
-   [¬P]{.P} → [¬Q]{.Q}
-   [¬P]{.P}
-   [¬Q]{.Q}
:::

Notice, however, that all the negations that are involved are *inside* the
boxes and circles. Negations inside the boxes and circles are not part of the
pattern. They are just along for the ride. (Compare that to the pattern that
defines MT: in that pattern, two of the negations are *outside* the boxes and
circles: those negations are a part of the pattern. They are not just along
for the ride.

Here is an example of this in English, to help make the point less abstractly:

::: {.standardform .liveshapes}
-   If [you are not a witch]{.A} then [you won't float.]{.B}
-   [You are not a witch]{.A}
-   [You won't float]{.B}
:::

This is MP. The argument works by affirming the antecedent, and then inferring
the affirmation of the consequent. There are negations involved, but they are
inside the antecedent and consequent, and play no essential role in the *form*
of the inference.
:::

```{.QualitativeProblem .MultipleChoice points=10}
25 <div class="standardform"> <ul> <li>¬P → Q</li> <li>¬Q</li> <li>¬¬P</li> </ul> </div>
| This is an instance of MP
| *This is an instance of MT
| This is not an instance of either MP or MT
```

:::{.reaction .correct ex=25}
If this one tripped you up, again, you need to focus on the *pattern*. Here is
the argument, with boxes and circles, showing how it fits the pattern of Modus
Tollens:

::: {.standardform .liveshapes}
-   [¬P]{.P} → [Q]{.Q}
-   ¬[Q]{.Q}
-   ¬[¬P]{.P}
:::

It happens to be that the antecedent is itself a negation, '¬P'. Modus Tollens
doesn't see that. It just knows that, since the other premise is the negation
of the consequent, the conclusion will be the negation of the antecedent.
Note that the *negation* of '¬P' is '¬¬P'. More generally, the *negation* of a
sentence, '[]{.P}', is that sentence, with an extra negation added in front,
'¬[].{P}'.
:::

:::solution
Finding all of this confusing? Here is another mini-lecture, working through
lots of examples, talking about how to recognize instances of rules.

::: youtube
<https://youtu.be/Ah8wlFjLQ88>
:::
:::
:::

## Using the Rules

We have four rules.
Let's use them!

But first, let me introduce another more compact way of representing arguments.
So far, we have been representing arguments in standard form, like this:

:::standardform
-   P → Q
-   P
-   Q
:::

But it is often convenient to be able to represent an argument all on one
line, listing the premises and conclusion horizontally, rather than
vertically, e.g.,

:::example
-   P → Q, P ∴ Q
:::

Notice that we separate the premises with commas, and mark the conclusion
using '∴'.
It is tempting to misread this, and think that it is a list with two elements:
'P → Q', and 'P ∴ Q'.
But it is a list with three elements:
 'P → Q', 'P', and 'Q'.
The '∴' symbol is not a connective,
 joining 'P' and 'Q' into a new sentence.
It is a conclusion marker.
One way to make that clearer is to enclose the premises in braces, presenting
them as a set:

:::example
-   $\{$P → Q, P$\}$ ∴ Q
:::

When we write arguments in this horizontal notation,
 we will often replace the three-dots symbol, '∴',
 with a "turnstyle": '⊢'.
This is just another way of marking a conclusion,
 and can also be read as 'therefore'.

:::example
-   P → Q, P ⊢ Q
:::

Again, it is tempting to read this as a list with two items, 'P → Q' and 'P ⊢
Q'. But it is a list with three items, one set off as the conclusion:

:::example
-   $\{$P → Q, P$\}$ ⊢ Q
:::

With that in mind, let's start using our rules.

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" init="now" submission="none"}
Ex P->Q, P :|-: Q
|1.P->Q :PR
|2.P    :PR
|3.Q    :MP 1,2
```

At the top, you see our argument, presented in the new horizontal notation.
Below that are three lines. On line (1), I have written the first premise, 'P
→ Q'. And I've indicated that this is a premise, by writing ':PR' next to it.
On line (2), I've done the same for the second premise, 'P'.
On line (3), I've applied the rule MP to lines (1) and (2), inferring 'Q'. I
indicate this by writing 'Q', followed by ':MP 1,2'.

Try it for yourself. Pay attention to the colons. If you are confused, watch
the video for further explanation and demonstration.

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
26 Q->R, Q :|-: R
```

:::solution
![Solution to 26](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/rule_CQR_Q.mp4)
:::

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
27 Q :|-: ~~Q 
```

:::solution
![Solution to 27](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/rule_Q_NNQ.mp4)
:::

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
28 P->Q, ~Q :|-: ~P 
```

:::solution
![Solution to 28](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/rule_CPQ_NQ_NP.mp4)
:::

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
29 (P/\Q)->~(R->S), ~~(R->S) :|-: ~(P/\Q)
```

:::solution
![Solution to 29](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/rule_ugly_MT.mp4)
:::

## Direct Derivations

Again, here is a short video lecture, to help orient you:

:::solution
::: youtube
<https://youtu.be/Psbwdq7TTGg>
:::
:::

[A [direct derivation (DD)]{.vocab} is a derivation that establishes that a
conclusion follows from the premises by deriving the conclusion directly from
the premises.]{.def} We call this a "direct" derivation in contrast to other
more roundabout methods of proof, which will be introduced in the next chapter. 

So the idea is to start from the premises, and proceed step by
step until we reach the conclusion. Each "step" must be an instance of one of
our inference rules.

For example, suppose we want to derive the conclusion of this argument from
its premises:

::: {.standardform}
-   If Neo takes the red pill, Neo stays in Wonderland.
-   If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes.
-   Neo takes the red pill.
-   Morpheus shows Neo how deep the rabbit hole goes.
:::

First, let's translate the argument into SL.

::: stickywrapper
::: soasticky
| P: Neo takes the red pill.
| Q: Neo stays in Wonderland.
| R: Morpheus shows Neo how deep the rabbit hole goes.
:::

::: standardform
-  P → Q
-  Q → R
-  P
-  R
:::

We begin by stating our conclusion, and indicating that it is our goal: it is
what we are trying to prove or *show*:

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
:::

Or, in SL:

::: proof
1.  [R]{.show}
:::

Next, we "bring down" each of our premises. That is, we write each premise on
a line, and indicate that it is a premise with ':PR':

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
2.  [If Neo takes the red pill, Neo stays in Wonderland. [PR]{.just}]{.indent}
3.  [If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes. [PR]{.just}]{.indent}
4.  [Neo takes the red pill [PR]{.just}]{.indent}
:::

And, following along in SL:

::: proof
1.  [R]{.show}
2.  [P → Q [PR]{.just}]{.indent}
3.  [Q → R [PR]{.just}]{.indent}
4.  [P [PR]{.just}]{.indent}
:::

Note the familiar ':PR', marking each as a premise. Note also the way we are
indenting each line below the first "show" line.

Notice that, from 2 and 4, we can infer Q: 'Neo stays in Wonderland', by MP. So
let's do that:

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
2.  [If Neo takes the red pill, Neo stays in Wonderland. [PR]{.just}]{.indent}
3.  [If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes. [PR]{.just}]{.indent}
4.  [Neo takes the red pill [PR]{.just}]{.indent}
5.  [Neo stays in Wonderland [MP 2,4]{.just}]{.indent}
:::

::: proof
1.  [R]{.show}
2.  [P → Q [PR]{.just}]{.indent}
3.  [Q → R [PR]{.just}]{.indent}
4.  [P [PR]{.just}]{.indent}
5.  [Q [MP 2,4]{.just}]{.indent}
:::

We have now established, on line (5), that Q: 'Neo stays in Wonderland' follows from our premises. But we
aren't done. Our goal is to establish that R: 'Morpheus shows Neo how deep the
rabbit hole goes' follows from our premises.

Notice that, from 3 and 5, we can reach our goal, again by applying MP:

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
2.  [If Neo takes the red pill, Neo stays in Wonderland. [PR]{.just}]{.indent}
3.  [If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes. [PR]{.just}]{.indent}
4.  [Neo takes the red pill [PR]{.just}]{.indent}
5.  [Neo stays in Wonderland [MP 2,4]{.just}]{.indent}
6.  [Morpheus shows Neo how deep the rabbit hole goes [MP 3,5]{.just}]{.indent}
:::

::: proof
1.  [R]{.show}
2.  [P → Q [PR]{.just}]{.indent}
3.  [Q → R [PR]{.just}]{.indent}
4.  [P [PR]{.just}]{.indent}
5.  [Q [MP 2,4]{.just}]{.indent}
6.  [R [MP 3,5]{.just}]{.indent}
:::

Success. We have reached our goal. We have reasoned, in two steps, from our premises to our conclusion.
Both steps are instances of MP, and MP is valid. This shows that our
argument is valid, and the conclusion follows from the premises.

One last step: a 'QED' line, announcing our success.
'QED' is short for 'quid erat demonstratum', which is Latin for 'it has been demonstrated'.
It is something mathematicians like to say when they have completed a proof.

But we are going to be a bit more specific.
To celebrate our completion, we add a line that doesn't just say 'QED', but
explains *what kind* of derivation this is, and *what line* shows that
we've succeeded. This is a Direct Derivation, and we reached our goal on line
6, so we write, on the last line, ':DD 6':

::: proof
1.  [Morpheus shows Neo how deep the rabbit hole goes.]{.show}
2.  [If Neo takes the red pill, Neo stays in Wonderland. [PR]{.just}]{.indent}
3.  [If Neo stays in Wonderland, Morpheus shows him how deep the rabbit hole
    goes. [PR]{.just}]{.indent}
4.  [Neo takes the red pill [PR]{.just}]{.indent}
5.  [Neo stays in Wonderland [MP 2,4]{.just}]{.indent}
6.  [Morpheus shows Neo how deep the rabbit hole goes [MP 3,5]{.just}]{.indent}
7.  [:DD 6]{.qed}
:::

::: proof
1.  [R]{.show}
2.  [P → Q [PR]{.just}]{.indent}
3.  [Q → R [PR]{.just}]{.indent}
4.  [P [PR]{.just}]{.indent}
5.  [Q [MP 2,4]{.just}]{.indent}
6.  [R [MP 3,5]{.just}]{.indent}
7.  [:DD 6]{.qed}
:::

Here is what this same derivation looks like when entered into Carnap:

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" init="now" submission="none"}
Example P->Q, Q->R, P :|-: R
|1.Show R
|2.  P->Q  :PR
|3.  Q->R  :PR
|4.  P     :PR
|5.  Q     :MP 2,4
|6.  R     :MP 3,5
|7.:DD 6
```

A few things to notice:

-   On each line, except for lines (1) and (7), we have both a sentence and a
    *justification*. The justification comes after the sentence, and is prefixed
    by a colon, ':'.

Show lines don't need justification: you can try to show whatever you want.
And QED lines don't contain any sentence: the sentence that is proven on a QED
line is the sentence on the corresponding show line. So, in this case, line
(7) establishes the truth of line (1).

Colons are mandatory. Carnap uses them to parse each line, and separate the
sentence from the justification. Some common mistakes:

-    The colon goes before the justification. It does not go between the rule
     and the cited line numbers: ':MP 2,4', not: '[MP: 2,4]{.xed}'.
-    Line numbers go *after* the rule, not before: ':MP 2,4', not: '[:2,4
     MP]{.xed}'
-    Do not put any space after the colon and before the justification: ':MP
     2,4', not: '[: MP 2,4]{.xed}'.
-    Do not put any space before the 'Show' on line (1). 

Our system is a version of an older system, but has been simplified for the
sake of typing into a computer.
In the older system, there were no QED lines. 
When you completed a derivation, 
 you drew a *box* around all the lines indented below
 the show line, and you crossed out the word 'show':

::: {.proof .km}
1.  [R]{.show}
2.  [P → Q [PR]{.just}]{.indent}
3.  [Q → R [PR]{.just}]{.indent}
4.  [P [PR]{.just}]{.indent}
5.  [Q [MP 2,4]{.just}]{.indent}
6.  [R [MP 3,5]{.just}]{.indent}
:::

Crossing out the word "show" was meant to visually emphasize the transformation of line
(1) that occurs when the derivation is complete:
 it goes from being a *goal* to an *accomplishment*,
 an *intention* to a justified *assertion*.

## Some Sample Direct Derivations

:::stickywrapper
:::{.aside .sticky .flex }
:::ruledisplay
**DNI and DNE**

:::{.displayed .liveshapes}
-   [ ]{.P} ⊢ ¬¬[ ]{.P} 
-  ¬¬[ ]{.P} ⊢ [ ]{.P}
:::
:::
:::ruledisplay
**MP**

:::{.displayed .liveshapes}
-   [ ]{.P}→[ ]{.Q}, [ ]{.P} ⊢ [ ]{.Q}
:::
:::
:::ruledisplay
**MT**

:::{.displayed .liveshapes}
-  [ ]{.P}→[ ]{.Q}, ¬[ ]{.Q} ⊢ ¬[ ]{.P}
:::
:::
:::

Try to complete the following derivation. Note that immediately following the
derivation is a *detailed* walk-through. It is fine to complete the derivation by
following the walk-through!

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10}
30 P->Q, ~Q :|-: ~P
```

First, enter your show line.
Put your cursor beside the '1.', and type: `Show ~P`, and type "enter" or
"return":

``` {.der}
Show ~P
```

Notice that Carnap automatically numbers the lines for you.
Also, case matters: make sure you typed in a capital `P`.

**Don't enter a space before the word "Show"** on line 1.
Carnap wants that first line to begin with the letter 'S',
 and will get confused if it begins with a space.

Indent your second line.
Every line *under a show line* needs to be indented.
My habit is to use two spaces to indent.
You can use one space,
 or three spaces,
 or a tab.
Whatever you do,
 be consistent.
If you sometimes use one space, sometimes two, and sometimes a tab,
 Carnap is going to get confused, and choke.

Now type in the first premise, and its justification: `P->Q :PR`, and type
"enter":

``` der
1.Show ~P
2.  P->Q :PR
3.  
```

Notice that Carnap adds the vertical bar for you.
That is not something you type.
It is a visual indicator,
 that helps you see that line (2) is part of a proof,
 aimed at showing line (1).

Now type in the second premise, and its justificaiton: `~Q :PR`.
Did you remember to indent?
Are your indentations consistent?
A common mistake is to "out-dent" negations,
 to make the lines look better visually. For example:

```xed 
1.Show ~P
2.  P->Q  :PR
3. ~Q     :PR
```

See how the 'Q' is aligned vertically under the 'P', 
 in a way that is pleasing to the eye?
That may be pleasing to the eye, 
 but it is confusing to Carnap!
Carnap wants consistent indentation,
 not visually pleasing indentation:

```xed 
1.Show ~P
2.  P->Q  :PR
3.  ~Q    :PR
```

See how the first character on line (2), 'P',
 is vertically aligned with the first character on line (3), '~'?
That is what Carnap wants.

Our next step is to apply MT:

``` der
1.Show ~P
2.  P->Q :PR
3.  ~Q   :PR
4.  ~P   :MT 2,3
```

Remember, when you apply a rule,
 you need a colon, ':', followed by the rule name, `MT`,
 followed by the line numbers that you are applying the rule to: '2,3'.
Do not separate the colon and the rule name with a space: `: MT`{.xed}.
Do separate the rule name and the line numbers with a space: `:MT 2,3`.
The line numbers can be separated by a comma, as here, or with a space, as you
wish.
Do not write: `:MT 23`{.xed}. Carnap will think you are trying to apply MT to
line 23, which is confusing, because line 23 doesn't exist.

The sentence on line (4) is the sentence on your show line.
So you have successfully completed this derivation.
The last step is to enter your QED line: `:DD 4`.
Note that your QED line is *not indented*.
The colon, ':', needs to be vertically aligned with the 'S' in your show line.

``` der
1.Show ~P
2.  P->Q :PR
3.  ~Q   :PR
4.  ~P   :MT 2,3
5.:DD 4
```
:::solution
![Solution to 30](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/der_CPQ_NQ_NP.mp4)
:::

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10} 
31 P->Q, Q->R, ~R :|-: ~P
```

:::solution
![Solution to 31](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/der_CPQ_CQR_NR_NP.mp4)
:::

So far, we haven't used DN for anything. Here is an example that requires DN:

``` {.ProofChecker .Prop options="guides fonts indent tabindent resize" points=10} 
32 ~P->~Q, Q :|-: P
```

And, again, here is a video demonstrating the solution:

:::solution
![Solution to 32](https://reggienet.illinoisstate.edu/access/content/user/desanso/public/vid/der_CNPNQ_Q_P.mp4)
:::

:::

## Wrapping Up

This chapter introduced four new rules of inference: DNE, DNI, MP, and
MT. Here they are, again, all together, in standard form, for easy reference:

:::flex
:::ruledisplay
**DNI**

::: {.standardform .liveshapes}
-   [ ]{.P}
-   ¬¬[ ]{.P} 
:::
:::

:::ruledisplay
**DNE**

::: {.standardform .liveshapes}
-  ¬¬[ ]{.P}
-  [ ]{.P}
:::
:::

:::ruledisplay
**MP**

::: {.standardform .liveshapes}
-  [ ]{.P}→[ ]{.Q}
-  [ ]{.P}
-  [ ]{.Q}
:::
:::

:::ruledisplay
**MT**

::: {.standardform .liveshapes}
-  [ ]{.P}→[ ]{.Q}
-  ¬[ ]{.Q}
-  ¬[ ]{.P}
:::
:::
:::

The chapter also introduced the simplest form of derivation: *Direct* Derivation
(DD). The next chapter will introduce two additional forms of derivation, and
it will introduce the idea of a *sub*-derivation—a derivation inside of a
derivation. 


<!-- vim: set ft=carnap :-->
